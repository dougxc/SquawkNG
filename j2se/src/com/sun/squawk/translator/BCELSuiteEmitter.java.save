package com.sun.squawk.translator;

import com.sun.squawk.translator.ir.*;
import com.sun.squawk.translator.util.RuntimeConstants;
import com.sun.squawk.util.IntHashtable;
import com.sun.squawk.translator.xml.XMLGraphPrinter;
import com.sun.squawk.translator.loader.SpecialTransformer;

import org.apache.bcel.*;
import org.apache.bcel.classfile.JavaClass;

import org.apache.bcel.generic.ClassGen;
import org.apache.bcel.generic.MethodGen;
import org.apache.bcel.generic.FieldGen;
import org.apache.bcel.generic.LocalVariableGen;
import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.InstructionFactory;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.InstructionHandle;
import org.apache.bcel.generic.InstructionConstants;
import org.apache.bcel.generic.StackProducer;
import org.apache.bcel.generic.BranchInstruction;
import org.apache.bcel.generic.GotoInstruction;
import org.apache.bcel.generic.InvokeInstruction;
import org.apache.bcel.generic.IfInstruction;
import org.apache.bcel.generic.ObjectType;
import org.apache.bcel.generic.ArrayType;
import org.apache.bcel.generic.Select;

import org.apache.bcel.generic.FCMPG;
import org.apache.bcel.generic.FCMPL;
import org.apache.bcel.generic.DCMPG;
import org.apache.bcel.generic.DCMPL;
import org.apache.bcel.generic.LCMP;
import org.apache.bcel.generic.ARRAYLENGTH;
import org.apache.bcel.generic.CHECKCAST;
import org.apache.bcel.generic.INSTANCEOF;
import org.apache.bcel.generic.PUSH;
import org.apache.bcel.generic.LOOKUPSWITCH;
import org.apache.bcel.generic.TABLESWITCH;
import org.apache.bcel.generic.MONITORENTER;
import org.apache.bcel.generic.MONITOREXIT;

import org.apache.bcel.util.Class2HTML;
import org.apache.bcel.util.ClassPath;

import java.io.*;
import java.util.*;

/**
 * This class implements a SuiteEmitter that uses the BCEL library to regenerate
 * standard Java class files corresponding to the classes in a suite.
 */
public class BCELSuiteEmitter extends DefaultSuiteEmitter implements InstructionVisitor, RuntimeConstants {

    /**
     * Specifies where to place generated class files.
     */
    final File dir;

    /**
     * Command line settable value for controlling disassembly of IR methods.
     */
    boolean disassemble;

    /**
     * Command line settable value for controlling tracing output.
     */
    boolean verbose;

    /**
     * Command line settable value for controlling verification of generated classes.
     */
    boolean verify;

    /**
     * Command line settable value for controlling whether or not to use Java
     * stack manipulation instructions or to emulate their semantics with
     * spills and fills.
     */
    boolean useStackOps;

    /**
     * The Tanslator context.
     */
    Translator vm;

    /**
     * These variables are required while building the bytecode for a method.
     */
    ClassGen           cg;
    FieldGen           fg;
    MethodGen          mg;
    ConstantPoolGen    cp;
    InstructionList    il;
    InstructionFactory factory;
    boolean            visiting;

    Instruction        current;      // The instruction currently being visited
    Instruction[]      ir;           // The IR for a method

    /**
     * The predecessor(s) to the current instruction that do not correspond to
     * Java bytecode instructions but were generated by the Translator to
     * implement part of the semantics of the current instruction. An example
     * is the CheckStore which is inserted before every StoreIndexed where the
     * array being stored into is a reference array. These instructions may
     * be branch targets and so need to be entered in the reloc table.
     */
    Vector predecessors = new Vector();

    /**
     * Map from instruction addresses in Translator IR to the
     * BCEL InstructionHandle objects wrapping the BCEL Instruction
     * created for the IR instructions at these addresses.
     */
    IntHashtable relocTable;

    /**
     * A flattened array of <org.apache.bcel.generic.BranchInstruction, com.sun.squawk.translator.ir.Instruction>
     * pairs indicating the branches that need their target's relocated once the
     * InstructionList has been built.
     */
    Vector relocPending;

    /**
     * The local variable allocation table for converting Squawk Locals to javac
     * local variable indexes.
     */
    Hashtable localVarTable;

    Vector javaClasses = new Vector();

    /**
     * General purpose statistic gathering table.
     */
    static Hashtable statistics = new Hashtable();

/*---------------------------------------------------------------------------*\
 *         BCEL types  <-> Translator types adaptors                         *
\*---------------------------------------------------------------------------*/

    /**
     * Convert a translator Type object to a BCEL Type object.
     * @param type The Translator Type object
     * @return the corresponding BCEL Type object
     */
    org.apache.bcel.generic.Type bcelType(Type type) {
        if (type == vm.NULLOBJECT) {
            return org.apache.bcel.generic.Type.NULL;
        }
        assume(type.name().charAt(0) != '-');
        return org.apache.bcel.generic.Type.getType(type.toSignature(true, false));
    }

    /**
     * Get the InstructionHandle corresponding to a IR instruction. This should
     * only be called once all the IR instructions have been visited.
     * @param irInst the IR instruction to translate.
     */
    InstructionHandle reloc(Instruction irInst) {
        assume(!visiting);
        InstructionHandle handle = (InstructionHandle)relocTable.get(irInst.getRelocIP());
        assume(handle != null);
        return handle;
    }

    /**
     * Convert a Squawk non-temporary or temporary local variable to a javac local.
     * @param local a Squawk local variable.
     * @param type the type of the local. This is not necessarily the same as
     * "local.type()" as temporaries can be be re-used with different types.
     * @return the index of the corresponding javac local variable.
     */
    int javacLocal(Local local, Type type) {
        // If type == vm.NULLOBJECT, then no type was determined for the local.
        // This will occur when a variable is declared and has null assigned to it.
        // It is safe to make the type Object.
        if (type == vm.NULLOBJECT) {
            if (!(local instanceof TemporaryLocal)) {
                type = local.type();
            }
            else {
                type = vm.OBJECT;
            }
        }
        assume(local instanceof TemporaryLocal || local.type() == type, " local="+local+" type="+type+" local.type()="+local.type());
        String asString = local.toString();
        Integer index = (Integer)localVarTable.get(asString);
        if (index == null) {
            mg.addLocalVariable("loc" + mg.getMaxLocals(), bcelType(type), null, null);
            index = new Integer(mg.getMaxLocals() - (local.type().isTwoWords() ? 2 : 1));
            localVarTable.put(asString, index);
        }
        return index.intValue();
    }

    /**
     * Do the reverse of the special method name transformations performed by
     * ClassFileLoader.
     * @param name The name of a method that may have been transformed by ClassFileLoader.
     * @return the name after any transformations have been undone.
     */
    String methodName(String name) {
        if (name == vm.SQUAWK_CLINIT) {
//            name = vm.CLINIT;
        }
        else if (name == vm.SQUAWK_DUMMY || name == vm.SQUAWK_INIT) {
            name = vm.INIT;
        }
        else if (name == vm.SQUAWK_MAIN) {
            name = vm.MAIN;
        }
        return name;
    }

    /**
     * Given an IntermediateMethod, convert it's list of parameter types to the
     * appropriate list of BCEL types for the method. This means making explicit the
     * first parameter the translator artificially inserted for static
     * methods and but leaving it implicit for non-static methods.
     * @param m The IntermediateMethod.
     * @return the converted parameter type list.
     */
    org.apache.bcel.generic.Type[] methodArgTypes(Method m) {
        Type[] params = m.getParms();
        int firstParm = (m.isStatic() ? 0 : 1);
        int nextLocalID = 0;
        org.apache.bcel.generic.Type[] arg_types = new org.apache.bcel.generic.Type[params.length - firstParm];
        for (int i = firstParm; i != params.length; i++) {
            arg_types[i - firstParm] = bcelType(params[i]);
        }
        return arg_types;
    }

    /**
     * Given an IntermediateMethod, convert it's return type to the
     * appropriate BCEL type.
     * @param m The IntermediateMethod.
     * @return the converted parameter type list.
     */
    org.apache.bcel.generic.Type methodReturnType(Method m) {
        if (m.name() == vm.SQUAWK_INIT) {
            return org.apache.bcel.generic.Type.VOID;
        }
        else {
            return bcelType(m.type());
        }
    }

    /**
     * Initialize the local variable table with the parameters to a method.
     * @param The new method.
     */
    void initializeLocalVarTable(Method m) {
        assume(mg != null);
        assume(localVarTable == null);

        localVarTable         = new Hashtable();
        Type[] params         = m.getParms();
        int nextLocalID       = 0;
        int nextJavacIndex    = 0;
        LocalVariableGen[] lg = mg.getLocalVariables();
        int lgi               = 0;

        assume(lg.length == params.length/* - (m.isStatic() ? 1 : 0)*/);
//        for (int i = (m.isStatic() ? 1 : 0); i != params.length; i++) {
        for (int i = 0; i != params.length; i++) {
            Local local = new Local(params[i].localType());
            local.setID(nextLocalID++);
            assume(lg[lgi++].getIndex() == nextJavacIndex);
            localVarTable.put(local.toString(), new Integer(nextJavacIndex));
            nextJavacIndex += (local.type().isTwoWords() ? 2 : 1);
        }
    }


/*---------------------------------------------------------------------------*\
 *         Main emitting methods                                             *
\*---------------------------------------------------------------------------*/

    /**
     * Create a suite emitter that will be generate a set of class files for the
     * class in a suite.
     * @param dirName Specifies where to place generated class files.
     */
    public BCELSuiteEmitter(String dirName) {
        this.dir = new File(dirName);
        if (!dir.exists()) {
            dir.mkdir();
        }
        else
        if (!dir.isDirectory()) {
            throw new RuntimeException(dir + " is not a directory");
        }
    }

    /**
     * Convert an IR Field into a BCEL field.
     * @param clazz The enclosing class
     * @param f The field to be converted.
     * @return the converted field.
     */
    org.apache.bcel.classfile.Field convertField(Type clazz, Field f) {
        if (verbose) {
            System.out.println("  Generating field " + f.toString());
        }
        Type fType   = f.type();
        assume(f.parent() == clazz);
        fg = new FieldGen(f.flags(),
                                bcelType(fType),
                                f.name(),
                                cp);
        Object initValue = f.getInitialValue();
        if (initValue != null) {
            if (initValue instanceof Long) {
                fg.setInitValue(((Long)initValue).longValue());
            }
            else
            if (initValue instanceof Float) {
                fg.setInitValue(((Float)initValue).floatValue());
            }
            else
            if (initValue instanceof Double) {
                fg.setInitValue(((Double)initValue).doubleValue());
            }
            else
            if (initValue instanceof Integer) {
                int value = ((Integer)initValue).intValue();
                if (fType == vm.INT) {
                    fg.setInitValue(value);
                }
                else
                if (fType == vm.SHORT) {
                    fg.setInitValue((short)value);
                }
                else
                if (fType == vm.CHAR) {
                    fg.setInitValue((char)value);
                }
                else
                if (fType == vm.BYTE) {
                    fg.setInitValue((byte)value);
                }
                else
                if (fType == vm.BOOLEAN) {
                    fg.setInitValue(value == 0 ? false : true);
                }
                else {
                    throw new RuntimeException(getContext(true) + "bad ConstantValue: " + initValue);
                }
            }
            else
            if (initValue instanceof String) {
                fg.setInitValue((String)initValue);
            }
            else {
                throw new RuntimeException(getContext(true) + "bad ConstantValue: " + initValue);
            }
        }
        org.apache.bcel.classfile.Field result = fg.getField();
        fg = null;
        return result;
    }

    /**
     * Convert an IR IntermediateMethod into a BCEL method.
     * @param clazz The enclosing class
     * @param m The method to be converted.
     * @return the converted method.
     */
    org.apache.bcel.classfile.Method convertMethod(Type clazz, IntermediateMethod m) {
        if (verbose) {
            System.out.println("  Generating method " + m.toString());
        }
        if (disassemble) {
            System.out.println("\nDisassembly for " + m.parent().getExternalName() + "." + m.toString());
            com.sun.squawk.translator.loader.GraphPrinter.print(System.out, m.getIR(), vm,m.name());
        }
        if (this.il == null) {
            this.il = new InstructionList();
        }
        else {
            il.dispose();
        }
        this.factory = new InstructionFactory(cg);
        this.mg = new MethodGen(m.flags(),
                methodReturnType(m),
                methodArgTypes(m),
                null,
                methodName(m.name()),
                m.parent().getExternalName(),
                il,
                cp);

        if (!(m.isAbstract() || m.isNative())) {
            try {
                initializeLocalVarTable(m);
                Instruction   ir = m.getIR();
                visiting         = true;
                relocTable       = new IntHashtable();
                relocPending     = new Vector();
                assume(ir != null);
                assume(ir instanceof MethodHeader);
                assume(instPrologue == null);
                Instruction.logicallyRelocateIR(ir.getNext(), 0);
                try {
                    for (current = ir; current != null; current = current.getNext()) {
                        current.visit(this);
                    }
                } catch (RuntimeException re) {
                    System.err.println("\nDisassembly for " + m.parent().getExternalName() + "." + m.toString());
                    com.sun.squawk.translator.loader.GraphPrinter.print(System.err, m.getIR(), vm,m.name());
                    re.printStackTrace();
                    assume(false);
                }
                visiting = false;

                // Complete the pending relocation of branch targets
                try {
                for (Enumeration e = relocPending.elements(); e.hasMoreElements();) {
                    BranchInstruction branch = (BranchInstruction)e.nextElement();
                    Instruction irBranch     = (Instruction)e.nextElement();
                    current = irBranch; // this is just to provide extra error message context
                    if (branch instanceof Select) {
                        // "switch" instructions
                        Select select = (Select)branch;
                        Target[] targets = ((SwitchInstruction)irBranch).targets();
                        for (int k = 0; k != targets.length; k++) {
                            Target t = targets[k];
                            Instruction irInst = t.getInstruction();
                            assume(irInst != null);
                            InstructionHandle handle = (InstructionHandle)relocTable.get(irInst.getRelocIP());
                            assume(handle != null);
                            select.setTarget(k, handle);
                        }
                        Target t = ((SwitchInstruction)irBranch).defaultTarget();
                        Instruction irInst = t.getInstruction();
                        assume(irInst != null);
                        InstructionHandle handle = (InstructionHandle)relocTable.get(irInst.getRelocIP());
                        assume(handle != null);
                        select.setTarget(handle);

                    }
                    else if (branch instanceof GotoInstruction || branch instanceof IfInstruction) {
                        Target t = ((Goto)irBranch).target();
                        Instruction irInst = t.getInstruction();
                        assume(irInst != null);
                        InstructionHandle handle = (InstructionHandle)relocTable.get(irInst.getRelocIP());
                        assume(handle != null, "no InstructionHandle for IP " + irInst.getRelocIP());
                        branch.setTarget(handle);
                    }
                    else {
                        throw new RuntimeException(getContext(true) + "unknown branch instuction type: " + branch);
                    }
                }
                } catch (RuntimeException re) {
                    System.err.println("\nDisassembly for " + m.parent().getExternalName() + "." + m.toString());
                    com.sun.squawk.translator.loader.GraphPrinter.print(System.err, m.getIR(), vm,m.name());
                    re.printStackTrace();
                    assume(false);
                }

                // Set the exception handler table
                Method.ExceptionHandler[] handlerTable = m.getHandlerTable();
                if (handlerTable != null && handlerTable.length > 0) {
                    for (int k = 0; k != handlerTable.length; k++) {
                        Method.ExceptionHandler entry = handlerTable[k];
                        mg.addExceptionHandler(reloc(entry.tryStart()),
                                reloc(entry.tryEnd()),
                                reloc(entry.handlerEntry()),
                                (ObjectType)bcelType(entry.catchType()));
                    }
                }
            } finally {
                visiting      = false;
                relocTable    = null;
                relocPending  = null;
                localVarTable = null;
                current       = null;
            }

            // Compute the correct max_locals value
            mg.setMaxLocals();

            // Compute the correct max_stack value
            mg.setMaxStack();
        }
        else {
            mg.setInstructionList(null);
        }

        org.apache.bcel.classfile.Method result = mg.getMethod();
        mg = null;
        return result;
    }

    /**
     * Convert an IR Type into a BCEL JavaClass.
     * @param clazz The type to convert.
     * @return the JavaClass corresponding to clazz
     */
    JavaClass convertClass(Type clazz) {
        if (verbose) {
            System.out.println("Generating class " + clazz.getExternalName());
        }
        Type superClass   = clazz.superClass();
        Type[] interfaces = clazz.getInterfaces();
        String[] inames = null;
        if (interfaces != null) {
            inames = new String[interfaces.length];
            for (int j = 0; j != inames.length; j++) {
                inames[j] = interfaces[j].getExternalName();
            }
        }
        this.cg = new ClassGen(clazz.getExternalName(),
                                   superClass == null ? null : superClass.getExternalName(),
                                   "<generated>",
                                   clazz.getAccessFlags(),
                                   inames);
        this.cp = cg.getConstantPool();

        // Add fields
        Field[] fields = clazz.getFields();
        for (int j = 0; j != fields.length; j++) {
            cg.addField(convertField(clazz, fields[j]));
        }

        // Add methods
        Method[] methods = clazz.getMethods();
        for (int j = 0; j != methods.length; j++) {
            if (methods[j].parent() == clazz) {
                org.apache.bcel.classfile.Method javaMethod = convertMethod(clazz, (IntermediateMethod)methods[j]);
                String codeLengthKey = clazz.getExternalName() + "." + methods[j] + ":codeLength";
                Integer codeLength = (Integer)vm.getStatistics().get(codeLengthKey);
                if (codeLength != null) {
                    statistics.put(codeLengthKey, new int[] { codeLength.intValue(), javaMethod.getCode().getCode().length});
                }
                cg.addMethod(javaMethod);
                mg = null;
            }
        }
        return cg.getJavaClass();
    }

    /**
     * Emit a physical representation of a Suite.
     * @param name The name of the suite
     * @param proxies The proxy classes of the suite.
     * @param classes The non-proxy classes of the suite.
     * @return true if the suite producer should traverse the subelements of the suite.
     * @exception IOException if there is an IO problem.
     */
    public boolean emitSuite(String name, Type[] proxies, Type[] classes) throws IOException {
/*
        System.out.println("Proxy classes:");
        for (int i = 0; i != proxies.length; i++) {
            System.out.println("\t" + proxies[i].getExternalName());
        }
        System.out.println("Suite classes:");
        for (int i = 0; i != classes.length; i++) {
            System.out.println("\t" + classes[i].getExternalName());
        }
*/
        Type[] allClasses = new Type[proxies.length + classes.length];
        if (allClasses.length == 0) {
            return false;
        }
        System.arraycopy(proxies, 0, allClasses, 0, proxies.length);
        System.arraycopy(classes, 0, allClasses, proxies.length, classes.length);

        vm = allClasses[0].getVM();

        for (int i = 0; i != allClasses.length; i++) {
            Type clazz = allClasses[i];
            JavaClass jc = convertClass(clazz);
            javaClasses.addElement(jc);
        }
        return false;
    }

    /**
     * Print the usage message.
     * @param errMsg An optional error message.
     */
    static void usage(String errMsg) {
        PrintStream out = System.out;
        if (errMsg != null) {
            out.println(errMsg);
        }
        out.println("Usage: BCELSuiteEmitter [-options] suite_root_class_name ");
        out.println("where options include:");
        out.println("    -d                  output directory for generated classes");
        out.println("    -dis                dump a disassembly of the IR bytecode for each method");
        out.println("    -V                  verbose tracing of classfile generation");
        out.println("    -usestackops        generate Java stack manipulation instructions instead of");
        out.println("                        emulating their semantics with spills and fills");
        out.println("    -verify             verify generated classes");
        out.println();
        out.println("... plus any of the options accepted by the translator specified below...");
        out.println();
        com.sun.squawk.translator.Main.usage(null);
    }

    /**
     * Main method.
     */
    public static void main(String[] args) throws Exception {
        // Extract the command line args pertaining to BCEL
        Vector translatorArgs = new Vector();
        boolean dis           = false;
        boolean verbose       = false;
        boolean verify        = false;
        String dir            = null;
        boolean useStackOps   = false;
        int nextArg = 0;
        for (int i = 0; i != args.length; i++) {
            if (args[i].equals("-d")) {
                dir = com.sun.squawk.translator.Main.getOptArg(args, ++i, "-d");
            }
            else if (args[i].equals("-dis")) {
                dis = true;
            }
            else if (args[i].equals("-V")) {
                verbose = true;
            }
            else if (args[i].equals("-verify")) {
                verify = true;
            }
            else if (args[i].equals("-usestackops")) {
                useStackOps = true;
            }
            else {
                translatorArgs.addElement(args[i]);
            }
        }
        if (dir == null) {
            usage("The -d option must be supplied");
            return;
        }
        if (!dir.endsWith(File.separator)) {
            dir += File.separator;
        }

        BCELSuiteEmitter emitter = new BCELSuiteEmitter(dir);
        emitter.disassemble = dis;
        emitter.verbose     = verbose;
        emitter.verify      = verify;
        emitter.useStackOps = useStackOps;
        args = new String[translatorArgs.size()];
        translatorArgs.copyInto(args);

        com.sun.squawk.translator.Main.main(args, emitter);

        // Iterate through the generated classes and dump them
        for (Enumeration e = emitter.javaClasses.elements(); e.hasMoreElements(); ) {
            JavaClass jc = (JavaClass)e.nextElement();
            if (verbose) {
                System.out.println("Dumping " + jc.getClassName());
            }
//            new Class2HTML(jc, dir);
            jc.dump(dir + jc.getClassName().replace('.', File.separatorChar) + ".class");
        }

        // Show stats.
        int codeLengthTotal_old = 0;
        int codeLengthTotal_new = 0;
        for (Iterator iter = statistics.entrySet().iterator(); iter.hasNext();) {
            Map.Entry entry = (Map.Entry)iter.next();
            String key  = (String)entry.getKey();
            if (key.indexOf("codeLength") != -1) {
                int[] data = (int[])entry.getValue();
                codeLengthTotal_old += data[0];
                codeLengthTotal_new += data[1];
                // Show only those that differ
                if (data[0] != data[1]) {
//                    System.out.println(key + " old="+data[0]+" new="+data[1]);
                }
            }
        }
        System.out.println("codeLengthTotal: old="+codeLengthTotal_old+" new="+codeLengthTotal_new);

        if (verify) {
            Vector classesToVerify = new Vector();
            for (Enumeration e = emitter.javaClasses.elements(); e.hasMoreElements(); ) {
                JavaClass jc = (JavaClass)e.nextElement();
                classesToVerify.addElement(jc.getClassName());
            }
            try {
                BCELVerifier verifier = new BCELVerifier(classesToVerify, dir, false);
                verifier.run(verbose);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }


/*---------------------------------------------------------------------------*\
 *         Implementation of the InstructionVisitor interface                *
\*---------------------------------------------------------------------------*/

    /**
     * The first BCEL emitted for the IR instruction currently being converted.
     * This required as there may be one or more load instructions emitted before the real BCEL
     * instruction is emitted. All branches must be relocated to target the first
     * such load instruction (if any).
     */
    InstructionHandle instPrologue;

    void fillx(Instruction operand) {
        assume(useStackOps);
        assume(operand != null);
        assume(operand.getTemporaryLocal() != null);
        il.append(factory.createLoad(bcelType(operand.type()), javacLocal(operand.getTemporaryLocal(), operand.type())));
    }

    void spillx(Instruction inst) {
        assume(useStackOps);
        assume(inst != null);
        assume(inst.getTemporaryLocal() != null);
        il.append(factory.createStore(bcelType(inst.type()), javacLocal(inst.getTemporaryLocal(), inst.type())));
    }

    /**
     * Append a Java bytecode instruction corresponding to a given IR instruction.
     * @param irInst The IR instruction.
     * @param javaInst The Java bytecode instruction.
     * @return The InstructionHandle to the Java instruction in its instruction list.
     */
    InstructionHandle append(Instruction irInst, org.apache.bcel.generic.Instruction javaInst) {
        InstructionHandle handle;
        if (javaInst instanceof BranchInstruction) {
            handle = il.append((BranchInstruction)javaInst);
        } else {
            handle = il.append(javaInst);
        }
        if (instPrologue != null) {
            handle = instPrologue;
            instPrologue = null;
        }
        relocTable.put(irInst.getRelocIP(), handle);
        // Put the predecessors (if any) into the relocation table in case there are any branches to it
        if (predecessors.size() > 0) {
            for (Enumeration e = predecessors.elements(); e.hasMoreElements(); ) {
                relocTable.put(((Instruction)e.nextElement()).getRelocIP(), handle);
            }
            predecessors.clear();
        }

        if (javaInst instanceof BranchInstruction) {
            relocPending.addElement(javaInst);
            relocPending.addElement(irInst);
        }

        return handle;
    }

    public void doArithmeticOp(ArithmeticOp inst) {
        Instruction left  = inst.left();
        Instruction right = inst.right();
        Op op = inst.op();
        assume(left.type().isPrimitive() && right.type().isPrimitive());
        if (!inst.isComparison()) {
            append(inst, factory.createBinaryOperation(op.symbol, bcelType(inst.type())));
        }
        else {
            if (op == OP_LCMP) { append(inst, InstructionConstants.LCMP); }
            else if (op == OP_FCMPL) { append(inst, InstructionConstants.FCMPL); }
            else if (op == OP_FCMPG) { append(inst, InstructionConstants.FCMPG); }
            else if (op == OP_DCMPL) { append(inst, InstructionConstants.DCMPL); }
            else if (op == OP_DCMPG) { append(inst, InstructionConstants.DCMPG); }
            else {
                throw new RuntimeException(getContext(true) + "Unknown ArithmeticOp: " + inst);
            }
        }
    }

    public void doArrayLength (ArrayLength inst) {
        Instruction array = inst.array();
        append(inst, InstructionConstants.ARRAYLENGTH);
    }

    public void doCheckCast (CheckCast inst) {
        Instruction value = inst.value();
        Type srcType      = value.type();
        Type dstType      = inst.checkType();
        append(inst, factory.createCast(bcelType(srcType), bcelType(dstType)));
        predecessors.addElement(inst);
    }

    public void doConvertOp (ConvertOp inst) {
        Instruction value = inst.value();
        Type srcType      = inst.fromType();
        Type dstType      = inst.type();
        append(inst, factory.createCast(bcelType(srcType), bcelType(dstType)));
    }

    public void doGoto (Goto inst) {
        Target dst = inst.target();
        append(inst, factory.createBranchInstruction(Constants.GOTO, null));
    }

    public void doHandlerEnter (HandlerEnter inst) {
        predecessors.addElement(inst);
    }

    public void doHandlerExit (HandlerExit inst) {
        predecessors.addElement(inst);
    }

    public void doIfOp (IfOp inst) {
        Instruction left  = inst.left();
        Instruction right = inst.right();
        Op op = inst.op();
        short opc = -1;
        boolean isCompareWithNullOrZero = false;
        boolean isObjectCompare = !(right.type().isPrimitive());
        if (left instanceof LoadConstant) {
            LoadConstant ldc = (LoadConstant)left;
            isCompareWithNullOrZero = (ldc.isConstNull() ||
                (ldc.isInt() && ldc.getInt() == 0));
        }
        if (isCompareWithNullOrZero) {
            if (isObjectCompare) {
                if (op == OP_EQ) { opc = Constants.IFNULL; }
                else if (op == OP_NE) { opc = Constants.IFNONNULL; }
            }
            else {
                if (op == OP_EQ) { opc = Constants.IFEQ; }
                else if (op == OP_NE) { opc = Constants.IFNE; }
                else if (op == OP_GT) { opc = Constants.IFGT; }
                else if (op == OP_GE) { opc = Constants.IFGE; }
                else if (op == OP_LT) { opc = Constants.IFLT; }
                else if (op == OP_LE) { opc = Constants.IFLE; }
            }
        }
        else {
            if (isObjectCompare) {
                if (op == OP_EQ) { opc = Constants.IF_ACMPEQ; }
                else if (op == OP_NE) { opc = Constants.IF_ACMPNE;   }
            }
            else {
                if (op == OP_EQ) { opc = Constants.IF_ICMPEQ; }
                else if (op == OP_NE) { opc = Constants.IF_ICMPNE; }
                else if (op == OP_GT) { opc = Constants.IF_ICMPGT; }
                else if (op == OP_GE) { opc = Constants.IF_ICMPGE; }
                else if (op == OP_LT) { opc = Constants.IF_ICMPLT; }
                else if (op == OP_LE) { opc = Constants.IF_ICMPLE; }
            }
        }
        if (opc == -1) {
            throw new RuntimeException(getContext(true) + "bad IfOp operator: " + op);
        }
        append(inst, factory.createBranchInstruction(opc, null));
    }

    public void doInstanceOf (InstanceOf inst) {
        Instruction value = inst.value();
        Type type = inst.checkType();
        if (type.isArray()) {
            append(inst, new INSTANCEOF(cp.addArrayClass((ArrayType)bcelType(type))));
        }
        else {
            append(inst, new INSTANCEOF(cp.addClass((ObjectType)bcelType(type))));
        }
    }

    public void doInvoke (Invoke inst) {
        Instruction[] parms = inst.parms();
        Method m = inst.method();

        short kind;
        if (inst.form() == Invoke.Form.STATIC) {
            kind = Constants.INVOKESTATIC;
        }
        else if (inst.form() == Invoke.Form.INIT || inst.form() == Invoke.Form.SUPER) {
            kind = Constants.INVOKESPECIAL;
        }
        else {
            if (m.parent().isInterface()) {
                kind = Constants.INVOKEINTERFACE;
            }
            else {
                kind = Constants.INVOKEVIRTUAL;
            }
        }

        append(inst, factory.createInvoke(m.parent().getExternalName(),
                             methodName(m.name()),
                             methodReturnType(m),
                             methodArgTypes(m),
                             kind));
        // Append a load if this was an invoke to a constructor whose value is used.
        if (m.name() == vm.SQUAWK_INIT) {
            if (parms[0] instanceof LoadLocal) {
                LoadLocal loadInst = (LoadLocal)parms[0];
                il.append(factory.createLoad(bcelType(inst.type()), javacLocal(loadInst.local(), loadInst.local().type())));
            }
            else if (parms[0] instanceof Invoke) {
                shouldNotReachHere();
            }
        }
    }

    public void doLoadConstant (LoadConstant inst) {
        PUSH push;
        if (inst.isInt()) {
            push = new PUSH(cp, inst.getInt());
        }
        else
        if (inst.isConstNull()) {
            push = new PUSH(cp, (String)null);
        }
        else
        if (inst.isDouble()) {
            push = new PUSH(cp, inst.getDouble());
        }
        else
        if (inst.isLong()) {
            push = new PUSH(cp, inst.getLong());
        }
        else
        if (inst.isFloat()) {
            push = new PUSH(cp, inst.getFloat());
        }
        else if (inst.isType()) {
            // ignore these
            return;
        }
        else {
            throw new RuntimeException(getContext(true) + "unknown load const instruction: " + inst);
        }
        append(inst, push.getInstruction());
    }

    public void doLoadConstantObject(LoadConstantObject inst) {
        int index   = inst.index();
        Type parent = inst.parent();
        String s = (String)parent.getConstantObject(index);
        append(inst, (new PUSH(cp, s)).getInstruction());
    }

    public void doLoadException (LoadException inst) {
        predecessors.addElement(inst);
    }

    public void doLoadField (LoadField inst) {
        Field f = inst.field();
        if (!f.isStatic()) {
            append(inst, factory.createGetField(f.parent().getExternalName(),
                    f.name(),
                    bcelType(f.type())));
        }
        else {
            append(inst, factory.createGetStatic(f.parent().getExternalName(),
                    f.name(),
                    bcelType(f.type())));
        }
    }

    public void doLoadIndexed (LoadIndexed inst) {
        Instruction array = inst.array();
        Instruction index = inst.index();
        append(inst, factory.createArrayLoad(bcelType(inst.type())));
    }

    public void doLoadLocal (LoadLocal inst) {
        Local local = inst.local();
        append(inst, factory.createLoad(bcelType(inst.type()), javacLocal(local, inst.type().localType())));
    }

    public void doLookupSwitch (LookupSwitch inst) {
        Instruction key = inst.key();
        int[] matches = inst.matches();
        InstructionHandle[] targets = new InstructionHandle[matches.length];
        append(inst, new LOOKUPSWITCH(matches, targets, null));
    }

    public void doMethodHeader (MethodHeader inst) {
        // do nothing
    }

    public void doMonitorEnter (MonitorEnter inst) {
        Instruction objectref = inst.value();
        append(inst, InstructionConstants.MONITORENTER);
    }

    public void doMonitorExit (MonitorExit inst) {
        Instruction objectref = inst.value();
        append(inst, InstructionConstants.MONITOREXIT);
    }

    public void doNegateOp (NegateOp inst) {
        Instruction value = inst.value();
        Type type = inst.type();

        if (type == vm.LONG) {
            append(inst, InstructionConstants.LNEG);
        }
        else if (type == vm.DOUBLE) {
            append(inst, InstructionConstants.DNEG);
        }
        else if (type == vm.INT) {
            append(inst, InstructionConstants.INEG);
        }
        else if (type == vm.FLOAT) {
            append(inst, InstructionConstants.FNEG);
        }
        else {
            throw new RuntimeException(getContext(true) + "unknown negate op: " + inst);
        }
    }

    public void doNewArray (NewArray inst) {
        // this should have already been converted to an invoke by SpecialTransformer
        shouldNotReachHere();
    }

    public void doNewMultiArray (NewMultiArray inst){
        // this should have already been converted to an invoke by SpecialTransformer
        shouldNotReachHere();
    }

    public void doNewObject (NewObject inst) {
        // this should have already been converted to an invoke by SpecialTransformer
        shouldNotReachHere();
    }

    public void doPop(Pop inst) {

    }

    public void doNewDimension(NewDimension inst) {

    }

    public void doPhi (Phi inst) {
        predecessors.addElement(inst);
    }

    public void doReturn (Return inst) {
        Instruction value = inst.value();
        Type type = inst.type();
        append(inst, factory.createReturn(bcelType(type)));
    }

    public void doStackOp(StackOp inst) {
        int opc  = inst.opc();
        int form = inst.form();
        Instruction value1 = inst.value1();
        Instruction value2 = inst.value2();
        Instruction value3 = inst.value3();
        Instruction value4 = inst.value4();
        if (opc != opc_pop && !useStackOps) {
            return;
        }
        switch(opc) {
            case opc_pop:
                append(inst, InstructionConstants.POP);
                break;
            case opc_pop2:
                append(inst, InstructionConstants.POP);
                append(inst, InstructionConstants.POP);
                break;
            case opc_dup:
                // This has to be a DUP as the idiom of NEW followed by DUP cannot
                // be replaced by spills and fills without violating the verification
                // constraint:
                //  "... an instance cannot be used until it is fully constructed."
//                append(inst, InstructionConstants.DUP);
                spillx(value1);
                fillx(value1);
                fillx(value1);
                break;
            case opc_dup_x1:
                spillx(value1);
                spillx(value2);
                fillx(value1);
                fillx(value2);
                fillx(value1);
                break;

            case opc_dup_x2:
                if (form == 1) {
                    spillx(value1);
                    spillx(value2);
                    spillx(value3);
                    fillx(value1);
                    fillx(value3);
                    fillx(value2);
                    fillx(value1);
                }
                else {
                    spillx(value1);
                    spillx(value2);
                    fillx(value1);
                    fillx(value2);
                    fillx(value1);
                }
                break;
            case opc_dup2:
                if (form == 1) {
                    spillx(value1);
                    spillx(value2);
                    fillx(value2);
                    fillx(value1);
                    fillx(value2);
                    fillx(value1);
                }
                else {
                    spillx(value1);
                    fillx(value1);
                    fillx(value1);
                }
                break;
            case opc_dup2_x1:
                if (form == 1) {
                    spillx(value1);
                    spillx(value2);
                    spillx(value3);
                    fillx(value2);
                    fillx(value1);
                    fillx(value3);
                    fillx(value2);
                    fillx(value1);
                }
                else {
                    spillx(value1);
                    spillx(value2);
                    fillx(value2);
                    fillx(value1);
                    fillx(value2);
                    fillx(value1);
                }
                break;
            case opc_dup2_x2:
                switch (form) {
                    case 1:
                        spillx(value1);
                        spillx(value2);
                        spillx(value3);
                        spillx(value4);
                        fillx(value2);
                        fillx(value1);
                        fillx(value4);
                        fillx(value3);
                        fillx(value2);
                        fillx(value1);
                        break;
                    case 2:
                        spillx(value1);
                        spillx(value2);
                        spillx(value3);
                        fillx(value1);
                        fillx(value3);
                        fillx(value2);
                        fillx(value1);
                        break;
                    case 3:
                        spillx(value1);
                        spillx(value2);
                        spillx(value3);
                        fillx(value2);
                        fillx(value1);
                        fillx(value3);
                        fillx(value2);
                        fillx(value1);
                        break;
                    case 4:
                        spillx(value1);
                        spillx(value2);
                        fillx(value1);
                        fillx(value2);
                        fillx(value1);
                        break;
                    default:
                        shouldNotReachHere();
                }
                break;
            case opc_swap:
                spillx(value1);
                spillx(value2);
                fillx(value1);
                fillx(value2);
                break;
            default:
                assume(false, "unknown StackOp opcode: " + opc);
        }
    }

    public void doStoreField (StoreField inst) {
        Instruction value  = inst.value();
        Field f = inst.field();
        if (!f.isStatic()) {
            append(inst, factory.createPutField(f.parent().getExternalName(),
                    f.name(),
                    bcelType(f.type())));
        }
        else {
            append(inst, factory.createPutStatic(f.parent().getExternalName(),
                    f.name(),
                    bcelType(f.type())));
        }
    }

    public void doStoreIndexed (StoreIndexed inst) {
        Instruction array = inst.array();
        Instruction index = inst.index();
        Instruction value = inst.value();
        Type type         = inst.basicType();
        append(inst, factory.createArrayStore(bcelType(type.elementType())));
    }

    public void doStoreLocal (StoreLocal inst) {
        Instruction value = inst.value();
        Local local = inst.local();
        append(inst, factory.createStore(bcelType(local.type()), javacLocal(local, value.type().localType())));
    }

    public void doTableSwitch (TableSwitch inst) {
        Instruction key = inst.key();
        int low  = inst.low();
        int high = inst.high();
        int[] matches = new int[(high - low) + 1];
        InstructionHandle[] targets = new InstructionHandle[matches.length];
        for (int i = 0; i != matches.length;i++) {
            matches[i] = low + i;
        }
        append(inst, new TABLESWITCH(matches, targets, null));
    }

    public void doThrow (Throw inst) {
        Instruction throwable = inst.value();
        append(inst, InstructionConstants.ATHROW);
    }

/*---------------------------------------------------------------------------*\
 *     Override error methods in BaseFunctions to provide extra context      *
\*---------------------------------------------------------------------------*/

    /**
     * Provide a context string for an error.
     * @param isPrefix If true, then this is a prefix for an error message.
     */
    public String getContext(boolean isPrefix) {
        if (cg == null) {
            return "";
        }
        String result = cg.getClassName();
        if (fg != null) {
            result += "." + fg.getName() + ":" + fg.getSignature();
        }
        else
        if (mg != null) {
            result += "." + mg.getName() + "(<" + mg.getArgumentTypes().length + " params>)";
            if (current != null) {
                result += " @ " + current;
            }
            return result;
        }
        if (isPrefix) {
            result += ": ";
        }
        return result;
    }


    /**
     * Override message-less 'assume' in BaseFunctions to provide extra context.
     */
    public void assume(boolean x) {
        super.assume(x, getContext(false));
    }

    /**
     * Override 'assume' in BaseFunctions to provide extra context.
     */
    public void assume(boolean x, String msg) {
        super.assume(x, getContext(true) + msg);
    }


}