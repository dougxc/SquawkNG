package com.sun.squawk.translator.suite.impl;

import java.io.*;
import java.util.*;

import com.sun.squawk.translator.*;
import com.sun.squawk.translator.ir.*;
import com.sun.squawk.translator.suite.*;
import com.sun.squawk.translator.suite.SuiteEmitter.*;
import com.sun.squawk.vm.*;

/**
 * This is an suite emitter implementation that generates the
 * "GeneratedObjectLayout.java" source file for the Squawk VM.
 */
public class GeneratedObjectLayoutEmitter implements SuiteEmitter {

    /**
     * The print stream to which the generated source will be written.
     */
    private PrintStream out;

    /**
     * The counter used to allocate unique identifiers for native methods.
     */
    private int nextNativeMethodIdentifier;

    /**
     * The map from a native method's signature (minus parameter and
     * return types) to its unique identifier.
     */
    private Map nativeMethodIdentifiers = new TreeMap();

    /**
     * The map from an instance field's signature to its VMAccessed
     * attribute value and its byte offset within an object. The
     * attribute value and offset are represented as a single integer
     * with the former occupying the high 16 bits and the latter
     * occupying the low 16 bits.
     */
    private Map instanceFieldAttributesAndOffsets = new TreeMap();

    /**
     * The map from the name of a static method in java.lang.VMExtension
     * to its offset.
     */
    private Map staticMethodOffsetsOfVMExtension = new TreeMap();

    /**
     * Generate the header of the VM source file.
     *
     * @param name
     * @param isFinal
     * @param binds
     */
    public void emitSuiteStart(String name, boolean isFinal, String[] binds) {
        Assert.that(binds.length == 0, "Cannot generate GeneratedObjectLayout.java from non-core suite");
        out.println("//J2C:gol.c **DO NOT DELETE THIS LINE**");
        out.println("/* THIS FILE WAS GENERATED BY THE TRANSLATOR - DO NOT EDIT */");
        out.println("/*IFJ*/package com.sun.squawk.vm;");
        out.println("/*IFJ*/abstract public class GeneratedObjectLayout extends Segments {");
        out.println();
    }

    /**
     * Generate the tail of the source file. This includes functions that can
     * be used by the romizer to ensure that the layout of the core classes
     * as specified in the generated functions and offsets is consistent the
     * core classes being romized.
     */
    public void emitSuiteEnd() {
        out.println();

        out.println("//IFC//#if 0");
        out.println();
        out.println("    public static int getNativeMethodIdentifierFor(String className, String methodName) {");
        out.println("        String classAndMethodName = className + '.' +methodName;");
        for (Iterator iterator = nativeMethodIdentifiers.entrySet().iterator(); iterator.hasNext();) {
            Map.Entry entry = (Map.Entry)iterator.next();
            String classAndMethodName = (String)entry.getKey();
            int identifier = ((Integer)entry.getValue()).intValue();
            out.println("        if (classAndMethodName.equals(\""+classAndMethodName+"\")) return "+identifier+";");
        }
        out.println("        return -1;");
        out.println("    }");

        out.println();
        out.println("    public static int getInstanceFieldAttributesAndOffset(String className, String fieldName) {");
        out.println("        String classAndFieldName = className + '.' +fieldName;");
        for (Iterator iterator = instanceFieldAttributesAndOffsets.entrySet().iterator(); iterator.hasNext();) {
            Map.Entry entry = (Map.Entry)iterator.next();
            String classAndFieldName = (String)entry.getKey();
            int attributesAndOffset = ((Integer)entry.getValue()).intValue();
            String attributes = Integer.toHexString(attributesAndOffset >>> 16).toUpperCase();
            int offset = attributesAndOffset & 0xFFFF;
            while (attributes.length() < 4) {
                attributes = "0" + attributes;
            }
            out.println("        if (classAndFieldName.equals(\""+classAndFieldName+"\")) return (0x"+
                        attributes+" << 16) | "+offset+";");
        }
        out.println("        return -1;");
        out.println("    }");

        out.println();
        out.println("    public static int getOffsetForStaticMethodInVMExtension(String methodName) {");
        for (Iterator iterator = staticMethodOffsetsOfVMExtension.entrySet().iterator(); iterator.hasNext();) {
            Map.Entry entry = (Map.Entry)iterator.next();
            String methodName = (String)entry.getKey();
            int offset = ((Integer)entry.getValue()).intValue();
            out.println("        if (methodName.equals(\""+methodName+"\")) return "+offset+";");
        }
        out.println("        return -1;");
        out.println("    }");
        out.println("//IFC//#endif /* 0 */");
        out.println("/*IFJ*/}");
    }

    /**
     * Create the name of an accessor method. Getter accessors for boolean
     * typed fields start with 'is' or 'has'. All other accessors start with
     * 'get' or 'set' as appropriate.
     *
     * @param prefix The prefix for the name.
     * @param isGetter True if this is for a 'getter' accessor.
     * @param isBoolean True if this is a 'getter' accessor that returns a
     * boolean value. Ignored if this is not a 'getter' accessor.
     * @param fieldName The name of the field for which the accessor method is
     * being generated.
     * @return
     */
    private String makeAccessorName(String prefix,
                                boolean isGetter,
                                boolean isBoolean,
                                String fieldName) {
        if (isGetter) {
            if (isBoolean && (fieldName.startsWith("is") || fieldName.startsWith("has"))) {
                return prefix + fieldName;
            } else {
                return prefix + "get"+Character.toUpperCase(fieldName.charAt(0)) + fieldName.substring(1);
            }
        } else {
            return prefix + "set"+Character.toUpperCase(fieldName.charAt(0)) + fieldName.substring(1);
        }
    }

    /**
     * Generate the getter accessor for a field.
     *
     * @param out
     * @param accessorPrefix
     * @param type
     * @param name
     * @param byteOffset
     * @param access
     */
    void generateGetter(String accessorPrefix,
                        int type,
                        String name,
                        int byteOffset,
                        int access)
    {
        if ((access & SquawkConstants.VMACC_READ) == 0) {
            return;
        }
        boolean unsigned = (access & SquawkConstants.VMACC_UNSIGNED) != 0;
        String function = makeAccessorName(accessorPrefix, true, type == CNO.BOOLEAN, name);
        String returnType = "int  ";
        String resultConversion = "";
        int offset;
        String accessor;

        switch (type) {
            case CNO.BOOLEAN:
                accessor = "getByte";
                offset = byteOffset;
                returnType = "boolean ";
                resultConversion = " != 0";
                break;
            case CNO.BYTE:
                accessor = (unsigned ? "getUnsignedByte" : "getByte");
                offset = byteOffset;
                break;
            case CNO.SHORT:
                accessor = (unsigned ? "getUnsignedHalf" : "getHalf");
                offset = byteOffset / 2;
                break;
            case CNO.CHAR:
                accessor = ("getUnsignedHalf");
                offset = byteOffset / 2;
                break;
            case CNO.DOUBLE:
                // fall through ...
            case CNO.LONG:
                accessor = "getLong";
                returnType = "long ";
                offset = byteOffset / 8;
                break;
            case CNO.FLOAT:
                // fall through ...
            case CNO.INT:
                // fall through ...
            default:
                accessor = "getWord";
                offset = byteOffset / 4;
                break;
        }
        out.println("        /** Getter for '"+name+"'. */");
        out.println("/*MAC*/"+returnType+function+"(int $obj) { return "+accessor+"($obj, "+offset+")"+resultConversion+"; }");
    }

    /**
     * Generate the setter accessor for a field.
     *
     * @param out
     * @param accessorPrefix
     * @param type
     * @param name
     * @param byteOffset
     * @param access
     * @param classAccess
     */
    void generateSetter(String accessorPrefix,
                        int type,
                        String name,
                        int byteOffset,
                        int access,
                        int classAccess)
    {
        if ((access & SquawkConstants.VMACC_WRITE) == 0) {
            return;
        }
        boolean eeprom   = (classAccess & SquawkConstants.VMACC_EEPROM) != 0;
        boolean wbopaque = (access & SquawkConstants.VMACC_WBOPAQUE) != 0;

        String function = makeAccessorName(accessorPrefix, false, false, name);
        int offset;
        String parmType = "int";
        String accessor;
        String valueConversion = "";

        switch (type) {
            case CNO.BYTE:
                accessor = "setByte";
                offset = byteOffset;
                break;
            case CNO.BOOLEAN:
                accessor = "setByte";
                parmType = "boolean";
                valueConversion = " ? 1 : 0";
                offset = byteOffset;
                break;
            case CNO.CHAR:
                // fall through
            case CNO.SHORT:
                accessor = "setHalf";
                offset = byteOffset / 2;
                break;
            case CNO.DOUBLE:
                // fall through ...
            case CNO.LONG:
                accessor = "setLong";
                parmType = "long";
                offset = byteOffset / 8;
                break;
            case CNO.FLOAT:
                // fall through ...
            case CNO.INT:
                accessor = "setWord";
                offset = byteOffset / 4;
                break;
            default: // pointer type
                accessor = eeprom ? "setOop" : (wbopaque ? "setWord" : "setOopRam");
                offset = byteOffset / 4;
                break;
        }
        out.println("        /** Setter for '"+name+"'. */");
        out.println("/*MAC*/void "+function+"(int $obj, "+parmType+" $val) { "+accessor+"($obj, "+offset+", $val"+valueConversion+"); }");
    }

    /**
     * Generate the declarations of the methods used by the VM to access fields
     * of a class if its VMAccessed attributes specifies that it has fields that
     * are accessed by the VM.
     *
     * @param attribute
     * @param klass
     */
    private void generateInstanceFieldsAccessors(VMAccessedAttribute attribute, Type klass) {
        if (attribute.getInstanceFieldsTableSize() != 0) {
            String className = klass.suiteName();
            String prefix = className.substring(className.lastIndexOf('.')+1)+'_';
            Field[] fields = klass.getFields(false);
            int fieldIndex = 0;
            out.println();
            out.println("        /*");
            out.println("         * Accessors for "+className+" fields");
            out.println("         */");
            out.println();
            for (Enumeration e = attribute.getInstanceFieldsTableEntries(); e.hasMoreElements();) {
                VMAccessedAttribute.Item item = (VMAccessedAttribute.Item)e.nextElement();
                while (fields[fieldIndex].slot() != item.slot) {
                    Assert.that(fieldIndex < fields.length);
                    fieldIndex++;
                }
                Field field = fields[fieldIndex];
                int offset = getInstanceFieldsByteCount(klass, field);

                // Align the field
                int size = field.type().sizeOfField();
                offset = roundup(offset, size);

                generateSetter(prefix, field.type().suiteID(), field.name(), offset, item.accessFlags, attribute.classAccessFlags);
                generateGetter(prefix, field.type().suiteID(), field.name(), offset, item.accessFlags);

                String classAndFieldName = className+'.'+field.name();
                Integer attributesAndOffset = new Integer(item.accessFlags << 16 | offset);
                instanceFieldAttributesAndOffsets.put(classAndFieldName, attributesAndOffset);

            }
        }

    }

    /**
     * Generate the declarations of the offsets of the static methods in
     * java.lang.VMExtension that are invoked by the VM.
     *
     * @param attribute
     * @param klass
     */
    private void generateVMExtensionStaticMethodOffsets(VMAccessedAttribute attribute, Type klass) {
        if (attribute.getStaticMethodsTableSize() != 0) {
            String className = klass.suiteName();
            Assert.that(className.equals("java.lang.VMExtension"),
                        "Class other than java.lang.VMExtension cannot have '@vmaccessed: call' attribute: "+className);

            int maxOffset = -1;
            out.println();
            out.println("        /*");
            out.println("         * Offsets for java.lang.VMExtension's static methods");
            out.println("         */");
            out.println("        static final int ");
            out.println();

            Method[] methods = klass.getMethods(true);
            int methodIndex = 0;
            for (Enumeration e = attribute.getStaticMethodsTableEntries(); e.hasMoreElements();) {
                VMAccessedAttribute.Item item = (VMAccessedAttribute.Item)e.nextElement();
                while (methods[methodIndex].slot() != item.slot) {
                    Assert.that(methodIndex < methods.length);
                    methodIndex++;
                }
                Method method = methods[methodIndex];
                if ((item.accessFlags & SquawkConstants.VMACC_CALL) != 0) {
                    int offset = method.slot();
                    out.println("        java_lang_VMExtension_"+method.name()+" = "+offset+',');
                    staticMethodOffsetsOfVMExtension.put(method.name(), new Integer(offset));
                    if (offset > maxOffset) {
                        maxOffset = offset;
                    }
                }
            }

            if (maxOffset != -1) {
                out.println();
                out.println("        java_lang_VMExtension_MAX_OFFSET = " + maxOffset + ";");
                out.println();
            }
        }
    }

    /**
     * Generate the declarations (if any) dictated by the VMAccessed attribute
     * (if it exists) for a class.
     *
     * @param klass The class to which the attribute pertains.
     * @param attributes The attributes.
     */
    public void emitClassAttributes(Type klass, SuiteAttribute[] attributes) {
        if (attributes != null && attributes.length != 0) {
            for (int i = 0; i != attributes.length; ++i) {
                SuiteAttribute attribute = attributes[i];
                if (attribute instanceof VMAccessedAttribute) {
                    Assert.that(!klass.isProxy());
                    VMAccessedAttribute attr = (VMAccessedAttribute)attribute;

                    generateInstanceFieldsAccessors((VMAccessedAttribute)attribute, klass);
                    generateVMExtensionStaticMethodOffsets((VMAccessedAttribute)attribute, klass);
                }
            }
        }
    }

    /**
     * Calculate the amount of memory (in bytes) occupied by the fields of a
     * given class. Field offsets are aligned with respect to the their (e.g.
     * offsets of word fields are 4-byte aligned, offsets of short fields are
     * 2-byte aligned etc.). In addition, the first field within each class of
     * a hierachy is word aligned.
     *
     * @param klass A class whose fields' sizes are to be totaled.
     * @param field The delimiting field before which totalling is to stop
     * or null if all fields are to be included in the calculation.
     * @return
     */
    private int getInstanceFieldsByteCount(Type klass, Field field) {
        int total = 0;
        Field[] fields = klass.getFields(false);
        for (int i = 0; i != fields.length && field != fields[i]; ++i) {
            Field f = fields[i];
            if (f.includeInSuite()) {
                int size = f.type().sizeOfField();

                // Account for alignment
                total = roundup(total, size);
                total += size;
            }
        }

        if (klass.superClass() != null) {
            total += getInstanceFieldsByteCount(klass.superClass(), null);
        }

        if (field == null) {
            // Account for padding (if any) between class boundaries such that
            // the first field for each class in the hierarchy is word aligned.
            total = roundup(total, 4);
        }

        return total;
    }

    /**
     * Generate the native method identifier declarations for a set of methods.
     *
     * @param methods
     * @param methodsCount
     * @param isStatic
     * @param isProxy
     * @return
     */
    public boolean emitMethodsStart(Method[] methods,
                                    int methodsCount,
                                    boolean isStatic,
                                    boolean isProxy) {

        boolean doneHeader = false;
        String className = null;
        String prefix = null;
        for (int i = 0; i != methodsCount; ++i) {
            Method method = methods[i];
            if (method.isNative()) {
                if (!isStatic && !method.isFinal()) {
                    // Native methods in suite 0 must be final as calls to
                    // them are converted into 'invokenative' calls which
                    // are not polymorphic.
                    throw new LinkageError("Native virtual methods in suite 0 must be final: "+method);
                }
                if (!doneHeader) {
                    doneHeader = true;
                    className = method.parent().suiteName();
                    prefix = className.replace('.', '_')+'_';
                    out.println();
                    out.println("        /*");
                    out.println("         * Native method identifiers for "+(isStatic ? "static" : "virtual")+" methods in "+className);
                    out.println("         */");
                    out.println("        static final int ");
                } else {
                    out.println(",");
                }
                Integer identifier = new Integer(++nextNativeMethodIdentifier);
                out.print  ("        "+prefix+method.name()+" = "+identifier);
                nativeMethodIdentifiers.put(className+'.'+method.name(), identifier);
            }
        }

        if (doneHeader) {
            out.println(";");
            out.println();
        }

        return false;
    }

    /**
     * Roundup <code>value</code> to be a multiple of <code>size</code>.
     *
     * @param value The value to be rounded up.
     * @param size The size used for rounding. Must be 1, 2 or 4.
     * @return <code>(char)((value + (size-1)) & ~(1 << (size-1)))</code>
     */
    private int roundup(int value, int size) {
        switch (size) {
            case 1: break;
            case 2: value = (value+1)&0xFFFFFFFE; break;
            case 4: value = (value+3)&0xFFFFFFFC; break;
            default: throw new RuntimeException("bad roundup value="+value+" size="+size);
        }
        if ((value & 0xFFFF) != value) {
            throw new RuntimeException("overflow on roundup value="+value+" size="+size);
        }
        return value;
    }

    /*
     * The following code is simply implementations for the other methods
     * in the SuiteEmitter interface that should never be called or do nothing
     * if they are called.
     */

    public GeneratedObjectLayoutEmitter() {}
    public void emitComment(String prefix, String comment, boolean nl) {}
    public void init(OutputStream out, int flags, Hashtable properties) {
        Assert.that(this.out == null);
        this.out = new PrintStream(out);
    }
    public void close() {
        out.close();
    }
    public boolean isEmittingStackComments()            { return false;  }
    public boolean isEmittingComments()                 { return false;  }
    public boolean isEmittingMethodDebugAttribute()     { return false;  }

    public boolean emitSuite(String name, boolean isFinal, Type[] proxies, Type[] classes) { return true;  }
    public void emitAllClassesMetaInfoStart(int numClasses) {}
    public void emitAllClassesMetaInfoEnd() {}
    public boolean emitClassesMetaInfoStart(Type[] classes, boolean isProxy) {  return true; }
    public void emitClassesMetaInfoEnd() {}
    public boolean emitClassMetaInfoStart(Type type, boolean isProxy, boolean isLast) { return true; }
    public void emitClassMetaInfoEnd() {}
    public void emitClassType(Type type) {}
    public void emitClassAccessFlags(int accessFlags) {}
    public void emitClassName(String name) {}
    public void emitClassExtends(Type superClass) {}
    public void emitClassImplementsStart(int numInterfaces) {}
    public void emitClassImplementsEnd() {}
    public void emitInterfaceStart() {}
    public void emitInterfaceEnd() {}
    public void emitInterfaceType(Type type) {}
    public void emitInterfaceMethodImplementationSlotsStart(int numMethods) {}
    public void emitInterfaceMethodImplementationSlotsEnd() {}
    public void emitInterfaceMethodImplementationSlot(int slot) {}
    public void emitMemberName(String name) {}
    public boolean emitFieldsStart(Field[] fields, int fieldsCount, boolean isStatic, boolean isProxy) { return false; }
    public void emitFieldsEnd(boolean isStatic) {
        Assert.shouldNotReachHere();
    }
    public boolean emitFieldStart(Field field, boolean isProxy) {
        Assert.shouldNotReachHere();
        return false;
    }
    public void emitFieldEnd() {
        Assert.shouldNotReachHere();
    }
    public void emitFieldType(Type type) {
        Assert.shouldNotReachHere();
    }
    public void emitFieldAccessFlags(int accessFlags) {
        Assert.shouldNotReachHere();
    }
    public void emitMethodsEnd(boolean isStatic) {}
    public boolean emitMethodStart(Method method, boolean isProxy) {
        Assert.shouldNotReachHere();
        return false;
    }
    public void emitMethodEnd() {}
    public void emitMethodType(Type receiver, Type[] parameters, Type returnType) {}
    public void emitMethodAccessFlags(int accessFlags) {}
    public void emitOverriddenAccessStart(int numOverrides) {}
    public void emitOverriddenAccessEnd() {}
    public void emitOverriddenAccessMethodStart(Method method) {}
    public void emitOverriddenAccessMethodEnd() {}
    public void emitOverriddenAccessMethodSlot(int slot) {}
    public void emitOverriddenAccessMethodAccess(int flags) {}
    public void emitClassReferences(Type[] classes) {}
    public boolean emitConstantsStart(Object[] constants) { return false; }
    public void emitConstantsEnd() {
        Assert.shouldNotReachHere();
    }
    public void emitStringConstant(int index, String constant) {
        Assert.shouldNotReachHere();
    }
    public void emitIntArrayConstant(int index, int[] constant) {
        Assert.shouldNotReachHere();
    }
    public void emitShortArrayConstant(int index, short[] constant) {
        Assert.shouldNotReachHere();
    }
    public void emitCharArrayConstant(int index, char[] constant) {
        Assert.shouldNotReachHere();
    }
    public void emitByteArrayConstant(int index, byte[] constant) {
        Assert.shouldNotReachHere();
    }
    public boolean emitMethodBodiesStart(int methodCount) { return false; }
    public void emitMethodBodiesEnd() {
        Assert.shouldNotReachHere();
    }
    public boolean emitMethodBodyStart(Method method) {
        Assert.shouldNotReachHere();
        return false;
    }
    public void emitMethodBodyEnd() {
        Assert.shouldNotReachHere();
    }
    public void emitMethodClass(Type ofClass) {
        Assert.shouldNotReachHere();
    }
    public void emitMethodSlot(int index) {
        Assert.shouldNotReachHere();
    }
    public void emitMethodImplAccessFlags(int flags) {
        Assert.shouldNotReachHere();
    }
    public void emitMethodLocals(Local[] locals) {
        Assert.shouldNotReachHere();
    }
    public void emitMethodMaxStack(int maxStack) {
        Assert.shouldNotReachHere();
    }
    public void emitExceptionHandlersStart(int numHandlers) {
        Assert.shouldNotReachHere();
    }
    public void emitExceptionHandlersEnd() {
        Assert.shouldNotReachHere();
    }
    public void emitExceptionHandlerStart() {
        Assert.shouldNotReachHere();
    }
    public void emitExceptionHandlerEnd() {
        Assert.shouldNotReachHere();
    }
    public void emitExceptionHandlerFrom(int from) {
        Assert.shouldNotReachHere();
    }
    public void emitExceptionHandlerTo(int to) {
        Assert.shouldNotReachHere();
    }
    public void emitExceptionHandlerEntry(int entry) {
        Assert.shouldNotReachHere();
    }
    public void emitExceptionHandlerCatchType(Type catchType) {
        Assert.shouldNotReachHere();
    }
    public boolean emitBytecodeStart(boolean firstPass, int length) { return false; }
    public void emitBytecodeEnd() {
        Assert.shouldNotReachHere();
    }
    public int emitArithmeticOp(IContext ctx, int opcode, int longFloatOpcode, boolean isFloat) {
        Assert.shouldNotReachHere();
        return 0;
    }
    public int emitArrayLoad(IContext ctx, int opcode) {
        Assert.shouldNotReachHere();
        return 0;
    }
    public int emitArrayStore(IContext ctx, int opcode) {
        Assert.shouldNotReachHere();
        return 0;
    }
    public int emitArrayLength(IContext ctx, int opcode) {
        Assert.shouldNotReachHere();
        return 0;
    }
    public BranchEncoding[] emitBranch(IContext ctx, int opcode, int offset, BranchEncoding enc) {
        Assert.shouldNotReachHere();
        return null;
    }
    public int emitCheckcast(IContext ctx, int opcode) {
        Assert.shouldNotReachHere();
        return 0;
    }
    public int emitConversion(IContext ctx, int opcode, int longFloatOpcode, boolean isFloat) {
        Assert.shouldNotReachHere();
        return 0;
    }
    public int emitLoadClass(IContext ctx, int opcode, int index) {
        Assert.shouldNotReachHere();
        return 0;
    }
    public int emitLoadConstant(IContext ctx, int opcode, long value) {
        Assert.shouldNotReachHere();
        return 0;
    }
    public int emitLoadConstantNull(IContext ctx, int opcode) {
        Assert.shouldNotReachHere();
        return 0;
    }
    public int emitLoadObject(IContext ctx, int opcode, int index) {
        Assert.shouldNotReachHere();
        return 0;
    }
    public int emitGetField(IContext ctx, int opcode, int slot) {
        Assert.shouldNotReachHere();
        return 0;
    }
    public int emitGetStatic(IContext ctx, int opcode, int slot) {
        Assert.shouldNotReachHere();
        return 0;
    }
    public int emitInstanceOf(IContext ctx, int opcode) {
        Assert.shouldNotReachHere();
        return 0;
    }
    public int emitIncDecLocal(IContext ctx, int opcode, int index) {
        Assert.shouldNotReachHere();
        return 0;
    }
    public int emitInvokeVirtual(IContext ctx, int opcode, int slot) {
        Assert.shouldNotReachHere();
        return 0;
    }
    public int emitInvokeSuper(IContext ctx, int opcode, int slot) {
        Assert.shouldNotReachHere();
        return 0;
    }
    public int emitInvokeStatic(IContext ctx, int opcode, int slot) {
        Assert.shouldNotReachHere();
        return 0;
    }
    public int emitInvokeInit(IContext ctx, int opcode, int slot) {
        Assert.shouldNotReachHere();
        return 0;
    }
    public int emitInvokeInterface(IContext ctx, int opcode, int slot) {
        Assert.shouldNotReachHere();
        return 0;
    }
    public int emitLoadLocal(IContext ctx, int opcode, int index) {
        Assert.shouldNotReachHere();
        return 0;
    }
    public int emitLookup(IContext ctx, int opcode) {
        Assert.shouldNotReachHere();
        return 0;
    }
    public int emitMonitorEnter(IContext ctx, int opcode) {
        Assert.shouldNotReachHere();
        return 0;
    }
    public int emitMonitorExit(IContext ctx, int opcode) {
        Assert.shouldNotReachHere();
        return 0;
    }
    public int emitNew(IContext ctx, int opcode) {
        Assert.shouldNotReachHere();
        return 0;
    }
    public int emitNewArray(IContext ctx, int opcode) {
        Assert.shouldNotReachHere();
        return 0;
    }
    public int emitNewDimension(IContext ctx, int opcode) {
        Assert.shouldNotReachHere();
        return 0;
    }
    public int emitPop(IContext ctx, int opcode) {
        Assert.shouldNotReachHere();
        return 0;
    }
    public int emitPutField(IContext ctx, int opcode, int slot) {
        Assert.shouldNotReachHere();
        return 0;
    }
    public int emitPutStatic(IContext ctx, int opcode, int slot) {
        Assert.shouldNotReachHere();
        return 0;
    }
    public int emitStoreLocal(IContext ctx, int opcode, int index) {
        Assert.shouldNotReachHere();
        return 0;
    }
    public int emitReturn(IContext ctx, int opcode) {
        Assert.shouldNotReachHere();
        return 0;
    }
    public BranchEncoding emitTableSwitch(IContext ctx, int opcode,
                                          boolean is16Bit, int defaultOffset,
                                          int lowMatch, int highMatch,
                                          int[] offsets, int padding) {
        Assert.shouldNotReachHere();
        return null;
    }
    public int emitThrow(IContext ctx, int opcode) {
        Assert.shouldNotReachHere();
        return 0;
    }
    public void emitMethodBodyAttributes(Method method, SuiteAttribute[] attributes) {
        Assert.shouldNotReachHere();
    }
}



