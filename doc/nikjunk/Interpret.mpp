//J2C:interp.c **DO NOT DELETE THIS LINE**
#comment {
/*---------------------------------------------------------------------------*\
 *                                   Macros                                  *
\*---------------------------------------------------------------------------*/
}



#comment {
/*---------------------------------------------------------------*\
 *               Check to see if a divisor is zero
\*---------------------------------------------------------------*/
}

#def div0Check(r) {
     if (r == 0) {
         fn = VMExtension_arithmeticException_3;
         break;
     }
}


#comment {
/*---------------------------------------------------------------*\
 *               Check to see if a pointer is zero
\*---------------------------------------------------------------*/
}

#def nullCheck(p) {
    if (#p# == 0) {
        fn = VMExtension_nullPointerException_5;        // If zero set error code
        break;                                          // Jump
    }                                                   // ...
}

#comment {


/*---------------------------------------------------------------*\
 *          Check to see if a pointer is zero and reset lp
\*---------------------------------------------------------------*/
}

#def nullCheckAndReset(p) {
    if (#p# == 0) {
        lp = Frame_getPreviousLp(lp);
        sp = lp + Frame_getStackOffset(lp);
        fn = VMExtension_nullPointerException_5;        // If zero set error code
        break;                                          // Jump
    }
}


#comment {
/*---------------------------------------------------------------*\
 *                         checkfield
\*---------------------------------------------------------------*/
}

#def checkfield_b(ref, off) {
    #nullCheck(ref)
    assume(Object_checkField(ref, off, 1));
}

#def checkfield_h(ref, off) {
    #nullCheck(ref)
    assume(Object_checkField(ref, off, 2));
}

#def checkfield_w(ref, off) {
    #nullCheck(ref)
    assume(Object_checkField(ref, off, 4));
}

#def checkfield_l(ref, off) {
    #nullCheck(ref)
    assume(Object_checkField(ref, off+1, 4));
}


#comment {
/*---------------------------------------------------------------*\
 *          Check to see if an array index is invalid
\*---------------------------------------------------------------*/
}

#def boundsCheck(p, i) {
    assume(Object_isArray(#p));
    if (#i# < 0 || #i# >= Object_getLength(#p#)) {
        fn = VMExtension_arrayBoundsException_4;
        break;
    }
}


#comment {
/*---------------------------------------------------------------*\
 * Check to see if a pointer is zero or an array index is invalid
\*---------------------------------------------------------------*/
}

#def nullBoundsCheck(p, i) {
    #nullCheck(#p)
    #boundsCheck(#p, #i)
}


#comment {
/*---------------------------------------------------------------*\
 *                        Push a stack frame
\*---------------------------------------------------------------*/
}

#def pushFrame {
    {int oldlp = lp;                                    // Copy caller's lp
    Frame_setCurrentIp(lp, ip);                         // Save current ip
    lp = lp + Frame_getStackOffset(lp)+w2b(1);          // Make lp point to the start of the stack area
    Frame_setPreviousLp(lp, oldlp);}                    // Store the caller's lp into the new frame
}


#comment {
/*---------------------------------------------------------------*\
 *                        Setup a stack frame
\*---------------------------------------------------------------*/
}

#def setupFrame {
    Frame_setCurrentMp(lp, mp);                         // Save the current method
    Frame_setCurrentCp(lp, cp);                         // Save the current class
    Frame_setStackOffset(lp, -w2b(1));                  // Save the current class
    ip = mp + getUnsignedByte(mp, 0);                   // Set the ip to start executing the first bytecode
}




/* *** DO NOT EDIT THIS FILE IT WAS BUILD FROM INTERPRETER.MPP *** */

/*
 * Copyright 1994-2003 Sun Microsystems, Inc. All Rights Reserved.
 *
 * This software is the proprietary information of Sun Microsystems, Inc.
 * Use is subject to license terms.
 */

/*IFJ*/package com.sun.squawk.vm;
/*IFJ*/abstract class Interpret extends ObjectMemory implements com.sun.squawk.vm.BytecodeMnemonics  {

/*IFJ*/public final static int
//IFC//enum {

    TIMEQUANTA                          = 999999999,//255,

    Native_UNUSED_1                     = 1,
    Native_UNUSED_2                     = 2,
    Native_UNUSED_3                     = 3,
    Native_UNUSED_4                     = 4,
    Native_UNUSED_5                     = 5,
    Native_exec_6                       = 6,
    Native_exec_7                       = 7,
    Native_exec_8                       = 8,
    Native_UNUSED_9                     = 9,
    Native_parm_10                      = 10,
    Native_parm_11                      = 11,
    Native_UNUSED_12                    = 12,
    Native_error_13                     = 13,
    Native_result_14                    = 14,
    Native_getNewExecutionContext_15    = 15,
    Native_setExecutionContext_16       = 16,
    Native_primNewArray_17              = 17,
    Native_callStaticNoParm_18          = 18,
    Native_callStaticOneParm_19         = 19,
    Native_getSuiteList_20              = 20,
    Native_setSuiteList_21              = 21,
    Native_setOutOfMemoryError_22       = 22,
    Native_getargc_23                   = 23,
    Native_getargvchar_24               = 24,
    Native_exit_25                      = 25,
    Native_gc_26                        = 26,
    Native_freemem_27                   = 27,
    Native_totalmem_28                  = 28,
    Native_gettime_29                   = 29,
    Native_arraycopy_30                 = 30,
    Native_getevent_31                  = 31,
    Native_waitforevent_32              = 32,
    Native_fatalvmerror_33              = 33,
    Native_getclass_34                  = 34,
    Native_getarraylength_35            = 35,
    Native_putch_36                     = 36,
    Native_getMonitorQueue_37           = 37,
    Native_setMonitorQueue_38           = 38,
    Native_getClassState_39             = 39,
    Native_createClassState_40          = 40,
    Native_primGetStatic_41             = 41,
    Native_primGetStaticLong_42         = 42,
    Native_primPutStatic_43             = 43,
    Native_primPutStaticLong_44         = 44,
    Native_primPutStaticObj_45          = 45,
    Native_setClassState_46             = 46,
    Native_primNewObject_47             = 47,
    Native_math                         = 48, // Must be last
    Native_floatToIntBits               = Native_math+1,
    Native_doubleToLongBits             = Native_math+2,
    Native_intBitsToFloat               = Native_math+3,
    Native_longBitsToDouble             = Native_math+4,

    VMExtension_vmstart_1               = 1,
    VMExtension_initializeClass_2       = 2,
    VMExtension_arithmeticException_3   = 3,
    VMExtension_arrayBoundsException_4  = 4,
    VMExtension_nullPointerException_5  = 5,
    VMExtension_checkcast_6             = 6,
    VMExtension_instanceof_7            = 7,
    VMExtension_unused_8                = 8,
    VMExtension_yield_9                 = 9,
    VMExtension_getStatic_10            = 10,
    VMExtension_getStaticLong_11        = 11,
    VMExtension_putStatic_12            = 12,
    VMExtension_putStaticLong_13        = 13,
    VMExtension_putStaticObj_14         = 14,
    VMExtension_monitorEnter_15         = 15,
    VMExtension_monitorExit_16          = 16,
    VMExtension_newArray_17             = 17,
    VMExtension_newDimension_18         = 18,
    VMExtension_breakpoint_19           = 19,
    VMExtension_callrun_20              = 20,
    VMExtension_DUMMY=0
//IFC//}
;

/*IFJ*/boolean CHECKGUARDPUSH=true; // Useful test, but not always correct

/*IFJ*/private int sp;

/*IFJ*/private void push(int x) {
/*IFJ*/    if (CHECKGUARDPUSH && (x >= memoryGuardLow && x < memoryGuardHigh)) {
/*IFJ*/        throw new Error("Pushing address in guard area "+x);
/*IFJ*/    }
/*IFJ*/    sp += 4;
/*IFJ*/    setWord(sp, 0, x);
/*IFJ*/}
//IFC//##ifdef PRODUCTION
//IFC//##define push(x) { pushWord(sp, x); }
//IFC//##else
//IFC//##define push(x) { setWord((sp+=4, sp), 0, x); }
//IFC//##endif

/*IFJ*/private int pop() {
/*IFJ*/    int res = getWord(sp, 0);
/*IFJ*/    sp -= 4;
/*IFJ*/    return res;
/*IFJ*/}
//IFC//##ifdef PRODUCTION
//IFC//##define pop()     popWord(sp)
//IFC//##else
//IFC//##define pop()     getWord((sp-=4, sp+4), 0)
//IFC//##endif

/*if[LONGS]*/

/*IFJ*/private void pushLong(long x) {
/*IFJ*/    sp += 4;
/*IFJ*/    setLongAtWord(sp, 0, x);
/*IFJ*/    sp += 4;
/*IFJ*/}
//IFC//##ifdef PRODUCTION
//IFC//##define pushLong(x) { pushDWord(sp, x); }
//IFC//##else
//IFC//##define pushLong(x) { sp+=4; setLongAtWord(sp, 0, x); sp+=4; }
//IFC//##endif

/*IFJ*/private long popLong() {
/*IFJ*/    sp -= 4;
/*IFJ*/    long res = getLongAtWord(sp, 0);
/*IFJ*/    sp -= 4;
/*IFJ*/    return res;
/*IFJ*/}
//IFC//##ifdef PRODUCTION
//IFC//##define popLong()     popDWord(sp)
//IFC//##else
//IFC//##define popLong()     getLongAtWord((sp-=8, sp+4), 0)
//IFC//##endif



/*end[LONGS]*/

    int threadID = -1;

    void traceJavaStack()               {}
    void trace_threadID()               {}

//IFC//##ifdef TRACING

    abstract void setTraceGCVerbose(boolean x);
    abstract void setTraceGC(boolean x);
    abstract void setTraceAllocation(boolean x);

    abstract boolean getTraceGCVerbose();
    abstract boolean getTraceGC();
    abstract boolean getTraceAllocation();
    abstract boolean getTraceInstructions();

//IFC//##endif

    abstract int getArgumentCount();
    abstract int getArgumentChar(int arg, int pos);


/*---------------------------------------------------------------------------*\
 *                               addToClassState                             *
\*---------------------------------------------------------------------------*/

    void addToClassState(int cls, int cs) {
        int classHash = Class_getCno(cls) & (CLS_STATE_TABLE_SIZE - 1);
        int cstable = getClassStateTable();                         // Get Hashtable
        int first = getWord(cstable, classHash);                    // Lookup first;
        ClassState_setClass(cs, cls);                               // Set the class pointer
        ClassState_setNext(cs, first);                              // Set the next pointer
        setWord(cstable, classHash, cs);                            // make cs first in table=
    }


/*---------------------------------------------------------------------------*\
 *                                findClassState                             *
\*---------------------------------------------------------------------------*/

    int findClassState(int cls, int classHash) {
        int cstable = getClassStateTable();                         // Get Hashtable
        int first = getWord(cstable, classHash);                    // Lookup first (which cannot be cls);
        int prev = first;
        assume(first != cls);
        for (;;) {
            int cs = ClassState_getNext(prev);
            if (cs == 0) {
                break;
            }
            if (ClassState_getClass(cs) == cls) {
                ClassState_setNext(prev, ClassState_getNext(cs));   // unlink cs
                setWord(cstable, classHash, cs);                    // make cs first
                ClassState_setNext(cs, first);                      // chain old first onto cs
                return cs;
            }
            prev = cs;
        }

       /*
        * Here is bootstrapping issue. The class state for java.lang.Thread must be
        * allocated here in order to avoid an infinate recursion. Otherwise this is
        * a non critical spped optimization.
        */
        if ((Class_getAccess(cls) & ACC_MUSTCLINIT) != 0) {
            return 0; // Must do it using Class.initializeClass();
        } else {
            int siz = Class_getStaticFieldsLength(cls);
            int cs  = newArray(getClassFromCNO(GLOBAL_ARRAY), CLS_STATE_offsetToFields + siz);
            if (cs != 0) {
                addToClassState(cls, cs);
                return cs;
            } else {
                return 0;
            }
        }
    }


/*---------------------------------------------------------------------------*\
 *                            createExecutionContext                         *
\*---------------------------------------------------------------------------*/

    int createExecutionContext(int slot, int parm) {
        int cp    = getClassFromCNO(VMEXTENSION);
        int chunk = newStackChunk(0);

///*IFJ*/traceln("chunk                        ="+chunk);
        if (chunk != 0) {

            int lp    = chunk + w2b(STACK_HEADER_SIZE+FRAME_HEADER_SIZE);
            int sp    = lp - 4;
            int vtbl  = Class_getStaticMethods(cp);
            int mp    = getWord(vtbl, slot);
            int ip;
            if (parm != 0) {
                sp += 4;
                setWord(sp, 0, parm);
            }
            Frame_setPreviousLp(lp, 0);
            Frame_setStackOffset(lp, sp - lp);
            Frame_setCurrentMp(lp, mp);                         // Save the current method
            Frame_setCurrentCp(lp, cp);                         // Save the current class

            ip = mp + getUnsignedByte(mp, 0);                   // Set the ip to start executing the first bytecode

            Frame_setCurrentIp(lp, ip);
            StackChunk_setLastLp(chunk, lp);

///*IFJ*/traceln("StackChunk_getNext(chunk)    ="+StackChunk_getNext(chunk)    );
///*IFJ*/traceln("StackChunk_getPrev(chunk)    ="+StackChunk_getPrev(chunk)    );
///*IFJ*/traceln("StackChunk_getSize(chunk)    ="+StackChunk_getSize(chunk)    );
///*IFJ*/traceln("StackChunk_getLastLp(chunk)  ="+StackChunk_getLastLp(chunk)  );
///*IFJ*/traceln("StackChunk_getFirstLp(chunk) ="+StackChunk_getFirstLp(chunk) );

///*IFJ*/traceln("Frame_getCurrentMp(lp)       ="+Frame_getCurrentMp(lp)       );
///*IFJ*/traceln("Frame_getCurrentIp(lp)       ="+Frame_getCurrentIp(lp)       );
///*IFJ*/traceln("Frame_getPreviousLp(lp)      ="+Frame_getPreviousLp(lp)      );
///*IFJ*/traceln("Frame_getCurrentCp(lp)       ="+Frame_getCurrentCp(lp)       );
///*IFJ*/traceln("Frame_getStackOffset(lp)     ="+Frame_getStackOffset(lp)     );

        }
        return chunk;
    }


/*---------------------------------------------------------------------------*\
 *                               getChunkFromFrame                           *
\*---------------------------------------------------------------------------*/

    int getChunkFromFrame(int lp) {
        while (Frame_getPreviousLp(lp) != 0) {
            lp = Frame_getPreviousLp(lp);
        }
        return lp - w2b(STACK_HEADER_SIZE + FRAME_HEADER_SIZE);
    }

/*---------------------------------------------------------------------------*\
 *                               traceInstruction                            *
\*---------------------------------------------------------------------------*/


//IFC//##ifdef PRODUCTION

    int lastMp;
    int lastMID;
    int lastPreamble;

    int countFrames(int lp) {
        int count = 0;
        for (;;) {
            while (Frame_getPreviousLp(lp) != 0) {
                lp = Frame_getPreviousLp(lp);
                count++;
            }
            int cc = getChunkFromFrame(lp);                 // get current chunk
            int pc = StackChunk_getPrev(cc);                // get previous chunk
            if (pc == 0) {
                break;
            } else {
                count++;
            }
            lp = StackChunk_getLastLp(pc);                  // get previous frame
            assume(lp != 0);

        }
        return count;
    }

    void traceInstruction(int ip, int lp, int sp, int cp) {
        if (getTraceInstructions()) {

///*IFJ*/traceln("ip="+ip+" lp="+lp+" sp="+sp+" cp="+cp);
///*IFJ*/traceln("Frame_getCurrentMp(lp)       ="+Frame_getCurrentMp(lp)       );
///*IFJ*/traceln("Frame_getCurrentIp(lp)       ="+Frame_getCurrentIp(lp)       );
///*IFJ*/traceln("Frame_getPreviousLp(lp)      ="+Frame_getPreviousLp(lp)      );
///*IFJ*/traceln("Frame_getCurrentCp(lp)       ="+Frame_getCurrentCp(lp)       );
///*IFJ*/traceln("Frame_getStackOffset(lp)     ="+Frame_getStackOffset(lp)     );

            int soff = Frame_getStackOffset(lp);
            int s0 = lp + soff;
            int b  = fetchUnsignedByte(ip);
            int mp = Frame_getCurrentMp(lp);
            int frames = countFrames(lp);

            if (mp != lastMp) {
                int methodIdAddr = getMethodIdAddress(mp);
                if (lastMID != -1) {
                    lastMID      = fetchInt(methodIdAddr);
                    lastPreamble = methodIdAddr + 4;
                } else {
                    lastMID      = -1;
                    lastPreamble = -1;
                }
                lastMp = mp;
            }

            trace("*TRACE*");
            traceInt(threadID);        trace(":"); // thread id
            traceInt(frames);          trace(":");
            traceInt(lastMID);         trace(":");
            traceInt(ip-lastPreamble); trace(":");


            trace("("); traceInt(sp); trace(")");

            traceTab(13);

            for (int i = s0+w2b(1) ; i <= sp ; i += w2b(1)) {
                trace(" "); traceInt(getWord(i, 0));
            }

            traceTab(39); trace(" ");

            ip++;

            if ((b >= OPC_WIDE_0 && b <= OPC_WIDE_15) || b == OPC_WIDE_HALF) {
                trace("["); trace(mnemonics[b]); trace("] ");
                int offset;
                if (b == OPC_WIDE_HALF) {
                    b = fetchUnsignedByte(ip++);
                    offset = fetchShort(ip);
                } else {
                    int wide_15 = (b&15) << 8;
                    b = fetchUnsignedByte(ip++);
                    offset = wide_15 | fetchUnsignedByte(ip);
                    offset = offset << 20 >> 20;
                }
                trace(mnemonics[b]); trace(" "); traceInt(offset);
            } else if (b == OPC_LONGOP) {
                trace(longMnemonics[fetchUnsignedByte(ip)]);
            } else if (b == OPC_FLOATOP) {
                trace(floatMnemonics[fetchUnsignedByte(ip)]);
            } else {
                trace(mnemonics[b]);
                int blth = (byte)(mainTable.charAt(b) >> 8);
                if (blth > 1) {
                    if (blth == 2) {
                        switch (b) {
                            case OPC_IF_ICMPEQ:  case OPC_IFEQ:
                            case OPC_IF_ICMPNE:  case OPC_IFNE:
                            case OPC_IF_ICMPLT:  case OPC_IFLT:
                            case OPC_IF_ICMPLE:  case OPC_IFLE:
                            case OPC_IF_ICMPGT:  case OPC_IFGT:
                            case OPC_IF_ICMPGE:  case OPC_IFGE:
                            case OPC_GOTO: trace(" "); traceInt(fetchByte(ip));         break;
                            default:       trace(" "); traceInt(fetchUnsignedByte(ip)); break;
                        }
                    } else if (blth == 3) {
                        trace(" "); traceInt(fetchShort(ip));
                    } else if (blth == 5) {
                        trace(" "); traceInt(fetchInt(ip));
                    } else if (blth == 9) {
                        trace(" "); traceLong(fetchLong(ip));
                    } else {
                        trace(" ???");
                    }
                }
            }

            traceln("");
        }
    }
//IFC//##else
//IFC//##define traceInstruction(ip, lp, sp, cp) /**/
//IFC//##endif



/*---------------------------------------------------------------------------*\
 *                                  interpret                                *
\*---------------------------------------------------------------------------*/

    int interpret(int startChunk, boolean gcWorked) {

        int bc, lp, ip, cp, sl, fn;
//IFC// int sp;
/*IFJ*/ int nativeParms[] = new int[16];
//IFC// int nativeParms[16];
        int nativePointer = 0;

        lp = StackChunk_getLastLp(startChunk);                  // Setup lp
        ip = Frame_getCurrentIp(lp);                            // Setup cp
        cp = Frame_getCurrentCp(lp);                            // Setup ip
        sp = lp + Frame_getStackOffset(lp);                     // Setup sp
        sl = startChunk + StackChunk_getSize(startChunk);       // Setup sl
        bc = TIMEQUANTA;                                        // Setup bc
        fn = VMExtension_yield_9;                               // Setup fn

        StackChunk_setLastLp(startChunk, 0);                    // Clear last frame pointer

        if (!gcWorked) {
            ip = getAddressOfThrowBytecode();
        }

        loop: for (;;) {
            int b;
            assume(fn == VMExtension_yield_9);
            incInstructionCount();
            traceInstruction(ip, lp, sp, cp);
            b = fetchUnsignedByte(ip++);
            switch (b) {

                /*-----------------------------------------------------------*\
                 *                          Constants                        *
                \*-----------------------------------------------------------*/

                case OPC_CONST_0:       push(0);                                                  continue;
                case OPC_CONST_1:       push(1);                                                  continue;
                case OPC_CONST_2:       push(2);                                                  continue;
                case OPC_CONST_3:       push(3);                                                  continue;
                case OPC_CONST_4:       push(4);                                                  continue;
                case OPC_CONST_5:       push(5);                                                  continue;
                case OPC_CONST_6:       push(6);                                                  continue;
                case OPC_CONST_7:       push(7);                                                  continue;
                case OPC_CONST_8:       push(8);                                                  continue;
                case OPC_CONST_9:       push(9);                                                  continue;
                case OPC_CONST_10:      push(10);                                                 continue;
                case OPC_CONST_11:      push(11);                                                 continue;
                case OPC_CONST_12:      push(12);                                                 continue;
                case OPC_CONST_13:      push(13);                                                 continue;
                case OPC_CONST_14:      push(14);                                                 continue;
                case OPC_CONST_15:      push(15);                                                 continue;
                case OPC_CONST_M1:      push(-1);                                                 continue;


                case OPC_CONST_BYTE:    push(fetchByte(ip));                             ip += 1; continue;


                case OPC_CONST_SHORT:   push(fetchShort(ip));                            ip += 2; continue;


                case OPC_CONST_CHAR:    push(fetchUnsignedShort(ip));                    ip += 2; continue;

                case OPC_CONST_INT:
                case OPC_CONST_FLOAT:   push(fetchInt(ip));                              ip += 4; continue;

                case OPC_CONST_LONG:
                case OPC_CONST_DOUBLE:  pushLong(fetchLong(ip));                         ip += 8; continue;


                /*-----------------------------------------------------------*\
                 *                     Object refererences                   *
                \*-----------------------------------------------------------*/

                case OPC_OBJECT_0:  push(getWord(Class_getObjectReferences(cp), 0));  continue;
                case OPC_OBJECT_1:  push(getWord(Class_getObjectReferences(cp), 1));  continue;
                case OPC_OBJECT_2:  push(getWord(Class_getObjectReferences(cp), 2));  continue;
                case OPC_OBJECT_3:  push(getWord(Class_getObjectReferences(cp), 3));  continue;
                case OPC_OBJECT_4:  push(getWord(Class_getObjectReferences(cp), 4));  continue;
                case OPC_OBJECT_5:  push(getWord(Class_getObjectReferences(cp), 5));  continue;
                case OPC_OBJECT_6:  push(getWord(Class_getObjectReferences(cp), 6));  continue;
                case OPC_OBJECT_7:  push(getWord(Class_getObjectReferences(cp), 7));  continue;
                case OPC_OBJECT_8:  push(getWord(Class_getObjectReferences(cp), 8));  continue;
                case OPC_OBJECT_9:  push(getWord(Class_getObjectReferences(cp), 9));  continue;
                case OPC_OBJECT_10: push(getWord(Class_getObjectReferences(cp), 10));  continue;
                case OPC_OBJECT_11: push(getWord(Class_getObjectReferences(cp), 11));  continue;
                case OPC_OBJECT_12: push(getWord(Class_getObjectReferences(cp), 12));  continue;
                case OPC_OBJECT_13: push(getWord(Class_getObjectReferences(cp), 13));  continue;
                case OPC_OBJECT_14: push(getWord(Class_getObjectReferences(cp), 14));  continue;
                case OPC_OBJECT_15: {
                    int refs = Class_getObjectReferences(cp);
                    push(getWord(refs, b&15));
                    continue;
                }
                case OPC_OBJECT: {
                    int refs = Class_getObjectReferences(cp);
                    push(getWord(refs, fetchUnsignedByte(ip++)));
                    continue;
                }


                /*-----------------------------------------------------------*\
                 *                      Class refererences                   *
                \*-----------------------------------------------------------*/

                case OPC_CLASS_0:   //push(getClassFromCNO(getUnsignedHalf(Class_getClassReferences(cp), 0))); continue;
                case OPC_CLASS_1:   //push(getClassFromCNO(getUnsignedHalf(Class_getClassReferences(cp), 1))); continue;
                case OPC_CLASS_2:   //push(getClassFromCNO(getUnsignedHalf(Class_getClassReferences(cp), 2))); continue;
                case OPC_CLASS_3:   //push(getClassFromCNO(getUnsignedHalf(Class_getClassReferences(cp), 3))); continue;
                case OPC_CLASS_4:   //push(getClassFromCNO(getUnsignedHalf(Class_getClassReferences(cp), 4))); continue;
                case OPC_CLASS_5:   //push(getClassFromCNO(getUnsignedHalf(Class_getClassReferences(cp), 5))); continue;
                case OPC_CLASS_6:   //push(getClassFromCNO(getUnsignedHalf(Class_getClassReferences(cp), 6))); continue;
                case OPC_CLASS_7:   //push(getClassFromCNO(getUnsignedHalf(Class_getClassReferences(cp), 7))); continue;
                case OPC_CLASS_8:   //push(getClassFromCNO(getUnsignedHalf(Class_getClassReferences(cp), 8))); continue;
                case OPC_CLASS_9:   //push(getClassFromCNO(getUnsignedHalf(Class_getClassReferences(cp), 9))); continue;
                case OPC_CLASS_10:  //push(getClassFromCNO(getUnsignedHalf(Class_getClassReferences(cp), 10))); continue;
                case OPC_CLASS_11:  //push(getClassFromCNO(getUnsignedHalf(Class_getClassReferences(cp), 11))); continue;
                case OPC_CLASS_12:  //push(getClassFromCNO(getUnsignedHalf(Class_getClassReferences(cp), 12))); continue;
                case OPC_CLASS_13:  //push(getClassFromCNO(getUnsignedHalf(Class_getClassReferences(cp), 13))); continue;
                case OPC_CLASS_14:  //push(getClassFromCNO(getUnsignedHalf(Class_getClassReferences(cp), 14))); continue;
                case OPC_CLASS_15: { //push(getClassFromCNO(getUnsignedHalf(Class_getClassReferences(cp), 14))); continue;
                    int refs = Class_getClassReferences(cp);
                    int type = getUnsignedHalf(refs, b&15);

///*IFJ*/traceln("cp        = "+cp);
///*IFJ*/traceln("refs      = "+refs);
///*IFJ*/traceln("type      = "+type);

                    int cls  = getClassFromCNO(type);


///*IFJ*/traceln("cls       = "+cls);

                    push(cls);
                    continue;
                }
                case OPC_CLASS: {
                    int refs = Class_getClassReferences(cp);
                    int type = getUnsignedHalf(refs, fetchUnsignedByte(ip++));
                    int cls  = getClassFromCNO(type);
                    push(cls);
                    continue;
                }


                /*-----------------------------------------------------------*\
                 *                    Local variable loads                   *
                \*-----------------------------------------------------------*/

                case OPC_LOAD_0:    push(Frame_getLocal(lp, 0));  continue;
                case OPC_LOAD_1:    push(Frame_getLocal(lp, 1));  continue;
                case OPC_LOAD_2:    push(Frame_getLocal(lp, 2));  continue;
                case OPC_LOAD_3:    push(Frame_getLocal(lp, 3));  continue;
                case OPC_LOAD_4:    push(Frame_getLocal(lp, 4));  continue;
                case OPC_LOAD_5:    push(Frame_getLocal(lp, 5));  continue;
                case OPC_LOAD_6:    push(Frame_getLocal(lp, 6));  continue;
                case OPC_LOAD_7:    push(Frame_getLocal(lp, 7));  continue;
                case OPC_LOAD_8:    push(Frame_getLocal(lp, 8));  continue;
                case OPC_LOAD_9:    push(Frame_getLocal(lp, 9));  continue;
                case OPC_LOAD_10:   push(Frame_getLocal(lp, 10)); continue;
                case OPC_LOAD_11:   push(Frame_getLocal(lp, 11)); continue;
                case OPC_LOAD_12:   push(Frame_getLocal(lp, 12)); continue;
                case OPC_LOAD_13:   push(Frame_getLocal(lp, 13)); continue;
                case OPC_LOAD_14:   push(Frame_getLocal(lp, 14)); continue;
                case OPC_LOAD_15:   push(Frame_getLocal(lp, 15)); continue;

                case OPC_LOAD:
                    push(Frame_getLocal(lp, fetchUnsignedByte(ip++)));
                    continue;

                case OPC_LOAD_I2: {
                    int  parm  = fetchUnsignedByte(ip++);
                    long value = Frame_getLocalLong(lp, parm);
///*IFJ*/traceln("OPC_LOAD_I2 lp="+lp+" parm="+parm+" value="+value);
                    pushLong(value);
                    continue;
                }


                /*-----------------------------------------------------------*\
                 *                    Local variable stores                  *
                \*-----------------------------------------------------------*/

                case OPC_STORE_0:   Frame_setLocal(lp, 0,  pop()); continue;
                case OPC_STORE_1:   Frame_setLocal(lp, 1,  pop()); continue;
                case OPC_STORE_2:   Frame_setLocal(lp, 2,  pop()); continue;
                case OPC_STORE_3:   Frame_setLocal(lp, 3,  pop()); continue;
                case OPC_STORE_4:   Frame_setLocal(lp, 4,  pop()); continue;
                case OPC_STORE_5:   Frame_setLocal(lp, 5,  pop()); continue;
                case OPC_STORE_6:   Frame_setLocal(lp, 6,  pop()); continue;
                case OPC_STORE_7:   Frame_setLocal(lp, 7,  pop()); continue;
                case OPC_STORE_8:   Frame_setLocal(lp, 8,  pop()); continue;
                case OPC_STORE_9:   Frame_setLocal(lp, 9,  pop()); continue;
                case OPC_STORE_10:  Frame_setLocal(lp, 10, pop()); continue;
                case OPC_STORE_11:  Frame_setLocal(lp, 11, pop()); continue;
                case OPC_STORE_12:  Frame_setLocal(lp, 12, pop()); continue;
                case OPC_STORE_13:  Frame_setLocal(lp, 13, pop()); continue;
                case OPC_STORE_14:  Frame_setLocal(lp, 14, pop()); continue;
                case OPC_STORE_15:  Frame_setLocal(lp, 15, pop()); continue;

                case OPC_STORE:
                    Frame_setLocal(lp, fetchUnsignedByte(ip++), pop());
                    continue;

                case OPC_STORE_I2: {
                    int  parm  = fetchUnsignedByte(ip++);
                    long value = popLong();
///*IFJ*/traceln("OPC_STORE_I2 lp="+lp+" parm="+parm+" value="+value);
                    Frame_setLocalLong(lp, parm, value);
                    continue;
                }


                /*-----------------------------------------------------------*\
                 *                   Inc/dec local variables                 *
                \*-----------------------------------------------------------*/

                case OPC_INC: {
                    int parm = fetchUnsignedByte(ip++);
                    Frame_setLocal(lp, parm, Frame_getLocal(lp, parm) + 1);
                    continue;
                }

                case OPC_DEC:  {
                    int parm = fetchUnsignedByte(ip++);
                    Frame_setLocal(lp, parm, Frame_getLocal(lp, parm) - 1);
                    continue;
                }


                /*-----------------------------------------------------------*\
                 *               Wide instructions (only branches)           *
                \*-----------------------------------------------------------*/

                case OPC_WIDE_0:
                case OPC_WIDE_1:
                case OPC_WIDE_2:
                case OPC_WIDE_3:
                case OPC_WIDE_4:
                case OPC_WIDE_5:
                case OPC_WIDE_6:
                case OPC_WIDE_7:
                case OPC_WIDE_8:
                case OPC_WIDE_9:
                case OPC_WIDE_10:
                case OPC_WIDE_11:
                case OPC_WIDE_12:
                case OPC_WIDE_13:
                case OPC_WIDE_14:
                case OPC_WIDE_15:
                case OPC_WIDE_HALF: {
                    int offset;
                    if (b == OPC_WIDE_HALF) {
                        b = fetchUnsignedByte(ip++);
                        offset = fetchShort(ip);  ip += 2;
                    } else {
                        int wide_15 = (b&15) << 8;
                        b = fetchUnsignedByte(ip++);
                        offset = wide_15 | fetchUnsignedByte(ip++);
                        offset = offset << 20 >> 20;
                    }
                    incBranchCount();
                    switch (b) {
                        case OPC_IFEQ:          if (pop() == 0)     ip += offset;   break;
                        case OPC_IFNE:          if (pop() != 0)     ip += offset;   break;
                        case OPC_IFLT:          if (pop() <  0)     ip += offset;   break;
                        case OPC_IFLE:          if (pop() <= 0)     ip += offset;   break;
                        case OPC_IFGT:          if (pop() >  0)     ip += offset;   break;
                        case OPC_IFGE:          if (pop() >= 0)     ip += offset;   break;
                        case OPC_IF_ICMPEQ:     if (pop() == pop()) ip += offset;   break;
                        case OPC_IF_ICMPNE:     if (pop() != pop()) ip += offset;   break;
                        case OPC_IF_ICMPLT:     if (pop() >  pop()) ip += offset;   break;
                        case OPC_IF_ICMPLE:     if (pop() >= pop()) ip += offset;   break;
                        case OPC_IF_ICMPGT:     if (pop() <  pop()) ip += offset;   break;
                        case OPC_IF_ICMPGE:     if (pop() <= pop()) ip += offset;   break;
                        case OPC_GOTO:                              ip += offset;   break;

                        default:                fatalVMError("Bad wide bytecode");
                    }
                    if (--bc > 0) {
                        continue;
                    } else {
                        break;
                    }
                }


                /*-----------------------------------------------------------*\
                 *                    Normal branches                        *
                \*-----------------------------------------------------------*/


                case OPC_IFEQ:          { int offset = fetchByte(ip++); if (pop() == 0)     ip += offset; incBranchCount(); if (--bc > 0) continue; else break; }
                case OPC_IFNE:          { int offset = fetchByte(ip++); if (pop() != 0)     ip += offset; incBranchCount(); if (--bc > 0) continue; else break; }
                case OPC_IFLT:          { int offset = fetchByte(ip++); if (pop() <  0)     ip += offset; incBranchCount(); if (--bc > 0) continue; else break; }
                case OPC_IFLE:          { int offset = fetchByte(ip++); if (pop() <= 0)     ip += offset; incBranchCount(); if (--bc > 0) continue; else break; }
                case OPC_IFGT:          { int offset = fetchByte(ip++); if (pop() >  0)     ip += offset; incBranchCount(); if (--bc > 0) continue; else break; }
                case OPC_IFGE:          { int offset = fetchByte(ip++); if (pop() >= 0)     ip += offset; incBranchCount(); if (--bc > 0) continue; else break; }
                case OPC_IF_ICMPEQ:     { int offset = fetchByte(ip++); if (pop() == pop()) ip += offset; incBranchCount(); if (--bc > 0) continue; else break; }
                case OPC_IF_ICMPNE:     { int offset = fetchByte(ip++); if (pop() != pop()) ip += offset; incBranchCount(); if (--bc > 0) continue; else break; }
                case OPC_IF_ICMPLT:     { int offset = fetchByte(ip++); if (pop() >  pop()) ip += offset; incBranchCount(); if (--bc > 0) continue; else break; }
                case OPC_IF_ICMPLE:     { int offset = fetchByte(ip++); if (pop() >= pop()) ip += offset; incBranchCount(); if (--bc > 0) continue; else break; }
                case OPC_IF_ICMPGT:     { int offset = fetchByte(ip++); if (pop() <  pop()) ip += offset; incBranchCount(); if (--bc > 0) continue; else break; }
                case OPC_IF_ICMPGE:     { int offset = fetchByte(ip++); if (pop() <= pop()) ip += offset; incBranchCount(); if (--bc > 0) continue; else break; }
                case OPC_GOTO:          { int offset = fetchByte(ip++);                     ip += offset; incBranchCount(); if (--bc > 0) continue; else break; }

                case OPC_STABLESWITCH_PAD:
                    ip++;
                case OPC_STABLESWITCH: {
                    int key, off, low, hi;
                    key = pop();
                    off = fetchShort(ip);        ip += 2;
                    low = fetchInt(ip);          ip += 4;
                    hi  = fetchInt(ip);          ip += 4;
                    if (key >= low && key <= hi) {
                        off = fetchShort(ip+((key-low)*2));
                    }
                    ip += off;
                    continue;
                }


                /*-----------------------------------------------------------*\
                 *                          Lookups                          *
                \*-----------------------------------------------------------*/

                #def lookup(suffix, get) {
                    case OPC_LOOKUP#suffix: {
                        int key, ref, lth, i, res = -1;
                        ref = pop();
                        key = pop();
                        lth = Object_getLength(ref);
                        for (i = 0 ; i < lth ; i++) {
                            int val = #get#(ref, i);
                            if (val == key) {
                                res = i;
                                break;
                            }
                        }
                        push(res);
                        continue;
                    }
                }
                #lookup(,   getWord)
                #lookup(_B, getByte)
                #lookup(_S, getHalf)
                #lookup(_C, getUnsignedHalf)


                /*-----------------------------------------------------------*\
                 *                         Invokes                           *
                \*-----------------------------------------------------------*/

                case OPC_INVOKEVIRTUAL:
                case OPC_INVOKEVIRTUAL1:
                case OPC_INVOKEVIRTUAL2: {
                    int mp;
                    int rcvr;
                    int vtbl;
                    int vstart;
                    int parm = fetchUnsignedByte(ip++);                 // Get the "number" operand of invoke
                    incInvokeCount();
                    #pushFrame

                    rcvr = Frame_getLocal(lp, 0);                       // Get the receiver

                    #nullCheckAndReset(rcvr)

                  cp = Object_getClass(rcvr);                         // Get the callee's class
                  vstart = Class_getFirstVirtualMethod(cp);           // Get the number of the first method defined
///*IFJ*/traceln("OPC_INVOKEVIRTUAL parm = "+parm+" cp="+cp+" vstart="+vstart);
                  for (;;) {
                      while (parm < vstart) {              // Is the target method there?
                          cp  = Class_getSuperClass(cp);              // Go to the super class
                          assume(cp != 0);
                          vstart = Class_getFirstVirtualMethod(cp);   // Get the number of the first method defined
///*IFJ*/traceln("OPC_INVOKEVIRTUAL parm = "+parm+" cp="+cp+" vstart="+vstart);
                      }                                               // Test again...
                      vtbl = Class_getVirtualMethods(cp);             // Get the vtable for virtual methods
                      assume(Object_isInBounds(vtbl, parm-vstart));
                      mp = getWord(vtbl, parm-vstart);                // Get the method
                      if (mp != 0) {
                          break;
                      } else {
                          cp  = Class_getSuperClass(cp);              // N - Go to the super class
                          assume(cp != 0);
                          vstart = Class_getFirstVirtualMethod(cp);   // Get the number of the first method defined                    }
///*IFJ*/traceln("OPC_INVOKEVIRTUAL parm = "+parm+" cp="+cp+" vstart="+vstart);
                      }
                  }

///*IFJ*/traceln("parm    = "+parm);
///*IFJ*/traceln("rcvr    = "+rcvr);
///*IFJ*/traceln("cp      = "+cp);
///*IFJ*/traceln("vstart  = "+vstart);
///*IFJ*/traceln("vtbl    = "+vtbl);
///*IFJ*/traceln("mp      = "+mp);


                    #setupFrame
                    continue;
                }

                case OPC_INVOKESUPER:
                case OPC_INVOKESUPER1:
                case OPC_INVOKESUPER2: {
                    int mp;
                    int vtbl;
                    int vstart;
                    int parm = fetchUnsignedByte(ip++);                 // Get the "number" operand of invoke
                    incInvokeCount();
                    #pushFrame

                    cp = pop();                                         // Get the callee's class
                    vstart = Class_getFirstVirtualMethod(cp);           // Get the number of the first method defined
                    for (;;) {
                        while (parm < vstart) {                         // Is the target method there?
                            cp  = Class_getSuperClass(cp);              // Go to the super class
                            assume(cp != 0);
                            vstart = Class_getFirstVirtualMethod(cp);   // Get the number of the first method defined
                        }                                               // Test again...
                        vtbl = Class_getVirtualMethods(cp);             // Get the vtable for virtual methods
                        assume(Object_isInBounds(vtbl, parm-vstart));
                        mp = getWord(vtbl, parm-vstart);                // Get the method
                        if (mp != 0) {
                            break;
                        } else {
                            cp  = Class_getSuperClass(cp);              // N - Go to the super class
                            assume(cp != 0);
                            vstart = Class_getFirstVirtualMethod(cp);   // Get the number of the first method defined                    }
                        }

                    }

///*IFJ*/traceln("parm    = "+parm);
///*IFJ*/traceln("cp      = "+cp);
///*IFJ*/traceln("vstart  = "+vstart);
///*IFJ*/traceln("vtbl    = "+vtbl);
///*IFJ*/traceln("mp      = "+mp);


                    #setupFrame
                    continue;
                }

                case OPC_INVOKEINIT:
                case OPC_INVOKEINIT1:
                case OPC_INVOKEINIT2:
                case OPC_INVOKESTATIC:
                case OPC_INVOKESTATIC1:
                case OPC_INVOKESTATIC2: {
                    int mp;
                    int vtbl;
                    int parm = fetchUnsignedByte(ip++);                 // Get the "number" operand of invoke
                    incInvokeCount();
                    #pushFrame

                    cp = pop();                                         // Get the callee's class
                    vtbl = Class_getStaticMethods(cp);                  // Get the vtable for virtual methods

///*IFJ*/traceln("parm    = "+parm);
///*IFJ*/traceln("cp      = "+cp);
///*IFJ*/traceln("vtbl    = "+vtbl);
///*IFJ*/traceln("Object_getLength(vtbl)    = "+Object_getLength(vtbl));

                    assume(Object_isInBounds(vtbl, parm));
                    mp = getWord(vtbl, parm);                           // Get the method

                    #setupFrame
                    continue;
                }

                case OPC_INVOKEINTERFACE:
                case OPC_INVOKEINTERFACE1:
                case OPC_INVOKEINTERFACE2: {
                    boolean found = false;
                    int mp;
                    int iklass;
                    int rcvr;
                    int rcvrClass;
                    int vtbl;
                    int vstart;
                    int iklassType;
                    int types;
                    int tlength;
                    int i;
                    int cno;
                    int parm = fetchUnsignedByte(ip++);                 // Get the "number" operand of invoke
                    incInvokeCount();
                    #pushFrame

                    iklass     = pop();                                 // Get the class of the interface
                    iklassType = Class_getCno(iklass);                  // Get the iklass cno
                    rcvr       = Frame_getLocal(lp, 0);                 // Get the receiver
                    rcvrClass  = Object_getClass(rcvr);                 // Get the receiver class

///*IFJ*/traceln("OPC_INVOKEINTERFACE parm       = "+parm);
///*IFJ*/traceln("OPC_INVOKEINTERFACE rcvr       = "+rcvr);
///*IFJ*/traceln("OPC_INVOKEINTERFACE rcvrType   = "+Class_getCno(rcvrClass));
///*IFJ*/traceln("OPC_INVOKEINTERFACE iklass     = "+iklass);
///*IFJ*/traceln("OPC_INVOKEINTERFACE iklassType = "+iklassType);

                    #nullCheck(rcvr)



                    for (;;) {
                        types   = Class_getInterfaceTypes(rcvrClass);       // Get the interface types table
                        tlength = Object_getLength(types);                  // Get the interface types table length

///*IFJ*/traceln("OPC_INVOKEINTERFACE types     = "+types);
///*IFJ*/traceln("OPC_INVOKEINTERFACE tlength   = "+tlength);


                        for (i = 0 ; i < tlength ; i++) {                   // Iterate through the interface types
                            assume(Object_isInBounds(types, i));
                            cno = getUnsignedHalf(types, i);                // Get the next type
///*IFJ*/traceln("OPC_INVOKEINTERFACE cno       = "+cno);

                            if (cno == iklassType) {                        // Match?
                                int slotTable;
                                int tables = Class_getInterfaceSlotTables(rcvrClass); // Y - Get the slot tables
///*IFJ*/traceln("OPC_INVOKEINTERFACE tables    = "+tables);
///*IFJ*/traceln("OPC_INVOKEINTERFACE tableslth = "+Object_getLength(tables));

                                assume(Object_isInBounds(tables, i));
                                slotTable = getWord(tables, i);             // Get specific table
///*IFJ*/traceln("OPC_INVOKEINTERFACE slotTable = "+slotTable);
                                assume(Object_isInBounds(slotTable, parm));
                                parm = getUnsignedByte(slotTable, parm);    // Get virtual method
///*IFJ*/traceln("OPC_INVOKEINTERFACE parm      = "+parm);
                                found = true;
                                break;
                            }
                        }
                        if (found) {
                            break;
                        }
                        rcvrClass  = Class_getSuperClass(rcvrClass);    // Try the next class up
                        assume(rcvrClass != 0);
///*IFJ*/traceln("OPC_INVOKEINTERFACE rcvr       = "+rcvr);
///*IFJ*/traceln("OPC_INVOKEINTERFACE rcvrType   = "+Class_getCno(rcvrClass));
                    }

                    cp = Object_getClass(rcvr);                         // Get the callee's class
                    vstart = Class_getFirstVirtualMethod(cp);           // Get the number of the first method defined
                    for (;;) {
                        while (parm < vstart) {                         // Is the target method there?
                            cp  = Class_getSuperClass(cp);              // N - Go to the super class
                            assume(cp != 0);
                            vstart = Class_getFirstVirtualMethod(cp);   // Get the number of the first method defined
                        }                                               // Test again...
                        vtbl = Class_getVirtualMethods(cp);             // Get the vtable for virtual methods
                        assume(Object_isInBounds(vtbl, parm-vstart));
                        mp = getWord(vtbl, parm-vstart);                // Get the method
                        if (mp != 0) {
                            break;
                        } else {
                            cp  = Class_getSuperClass(cp);              // N - Go to the super class
                            assume(cp != 0);
                            vstart = Class_getFirstVirtualMethod(cp);   // Get the number of the first method defined
                        }
                    }
                    #setupFrame
                    continue;
                }


                /*-----------------------------------------------------------*\
                 *                         Extend                            *
                \*-----------------------------------------------------------*/

                case OPC_EXTEND_0:
                case OPC_EXTEND_1:
                case OPC_EXTEND_2:
                case OPC_EXTEND_3:
                case OPC_EXTEND_4:
                case OPC_EXTEND_5:
                case OPC_EXTEND_6:
                case OPC_EXTEND_7:
                case OPC_EXTEND_8:
                case OPC_EXTEND_9:
                case OPC_EXTEND_10:
                case OPC_EXTEND_11:
                case OPC_EXTEND_12:
                case OPC_EXTEND_13:
                case OPC_EXTEND_14:
                case OPC_EXTEND_15:
                case OPC_EXTEND: {
                    int restartIP = ip - 1;
                    int nstack = (b == OPC_EXTEND) ? fetchUnsignedByte(ip++) : b&15;
                    int mp = Frame_getCurrentMp(lp);
                    int nlocals = getUnsignedByte(mp, MTH_numberOfLocals);

                    int zp = lp + w2b(FRAME_HEADER_SIZE + nlocals - 1);         // Point at last local
                    int ep = zp + w2b(nstack);                                  // Point past the last word used


///*IFJ*/traceln("nstack  = "+nstack);
///*IFJ*/traceln("nlocals = "+nlocals);
///*IFJ*/traceln("ip      = "+ip);
///*IFJ*/traceln("mp      = "+mp);
///*IFJ*/traceln("lp      = "+lp);
///*IFJ*/traceln("sp      = "+sp);
///*IFJ*/traceln("zp      = "+zp);
///*IFJ*/traceln("ep      = "+ep);
///*IFJ*/traceln("sl      = "+sl);


                    if (ep > sl) {                                              // Overflow?
                        int nlp, nsp;
                        int minsize = ep-lp+w2b(FRAME_HEADER_SIZE+STACK_HEADER_SIZE);// Work out the minimum needed
                        int cc = getChunkFromFrame(lp);                         // Get the current chunk
                        int nc = StackChunk_getNext(cc);                        // Get the next chumk if there is one
                        StackChunk_setNext(cc, 0);                              // Clear pointer
                        if (nc == 0 || StackChunk_getSize(nc) < minsize) {      // Large enough?
                            nc = newStackChunk(minsize);                        // Allocate chunk
                        }
                        if (nc == 0) {                                          // Failed?
                            Frame_setCurrentIp(lp, restartIP);                  // Set to re-execute the extend
                            Frame_setStackOffset(lp, sp - lp);                  // Save the stack offset
                            StackChunk_setLastLp(cc, lp);                       // Save the lp
                            return cc;                                          // Go do gc
                        }
                        sl = nc + StackChunk_getSize(nc);                       // Set up the sl for this chunk
                        StackChunk_setPrev(nc, cc);                             // Save the previous chunk address
                        StackChunk_setLastLp(nc, 0);                            // Needed?
                        StackChunk_setNext(cc, nc);                             // Save the next chunk
                        StackChunk_setLastLp(cc, Frame_getPreviousLp(lp));      // Save the last real frame
                        nlp = nc + w2b(STACK_HEADER_SIZE+FRAME_HEADER_SIZE);    // Get the next frame
                        Frame_setPreviousLp(nlp, 0);                            // This marks the first frame in the chunk

                        Frame_setCurrentMp(nlp, Frame_getCurrentMp(lp));        // Copy from old frame
                        Frame_setCurrentIp(nlp, Frame_getCurrentIp(lp));        // ...
                        Frame_setCurrentCp(nlp, Frame_getCurrentCp(lp));        // ...

                        nsp = nlp;                                              // Get start of param
                        while (lp <= sp) {                                      // Copy parms
                            setWord(nsp, 0, getWord(lp, 0));                    // ...
                            nsp += 4;                                           // ...
                            lp  += 4;                                           // ...
                        }                                                       //
                        lp = nlp;                                               // Get the new lp
                        sp = nsp;                                               // Get the new sp
                        zp = lp + w2b(FRAME_HEADER_SIZE + nlocals - 1);         // Point past last local



///*IFJ*/traceln("-lp      = "+lp);
///*IFJ*/traceln("-sp      = "+sp);
///*IFJ*/traceln("-zp      = "+zp);
///*IFJ*/traceln("-ep      = "+ep);
///*IFJ*/traceln("-sl      = "+sl);


                    }
                    while (sp != zp) {                                          // Zero locals
                        push(0);
                    }                                                           //
                    sp += w2b(FRAME_HEADER_SIZE - 1);                           // Skip frame
                    Frame_setStackOffset(lp, sp - lp);                          // Save the stack offset
                    continue;
                }


                /*-----------------------------------------------------------*\
                 *                         Returns                           *
                \*-----------------------------------------------------------*/


#def popframe {
                    {int plp = Frame_getPreviousLp(lp);                 // get previous lp
                    if (plp != 0) {                                     // zero?
                        sp = lp - w2b(1);                               // n - then set sp to our lp
                    } else {
                        int cc = getChunkFromFrame(lp);                 // get current chunk
                        int pc = StackChunk_getPrev(cc);                // get previous chunk
                        assume(pc != 0);
                        sl  = pc + StackChunk_getSize(pc);              // reset sl
                        plp = StackChunk_getLastLp(pc);                 // get previous frame
                        StackChunk_setLastLp(pc, 0);                    // clear last frame pointer
                        sp = plp + Frame_getStackOffset(plp);           // setup sp
                    }
                    lp = plp;                                           // get the previous lp
                    cp = Frame_getCurrentCp(lp);                        // reset cp
                    ip = Frame_getCurrentIp(lp);}                       // get next ip
}



                case OPC_RETURN:
                case OPC_RETURN1:
                case OPC_RETURN2: {
                    int oldsp = sp;

                    #popframe

                    switch (b) {
                        case OPC_RETURN2: {
                            long temp = getLongAtWord(oldsp, -1);
                            pushLong(temp);
                            break;
                        }

                        case OPC_RETURN1: {
                            int temp1 = getWord(oldsp, 0);
                            push(temp1);
                            break;
                        }
                    }
                    continue;
                }


                /*-----------------------------------------------------------*\
                 *                           Throw                           *
                \*-----------------------------------------------------------*/

                case OPC_THROW: {
                    int cls;
                    int exception;
                    if (gcWorked) {
                        exception = pop();
                    } else {
                        // Hack for entry to interpret() with gc failure
                        exception = getOutOfMemoryError();
                        ip = Frame_getCurrentIp(lp); // Get the real ip
                        gcWorked = true;             // Reset flag
                    }
                    if (exception == 0) {
                        fatalVMError("OPC_THROW of null exception object");
                    }

///*IFJ*/traceln("Throw     exception = "+exception);
                    cls = Object_getClass(exception);
///*IFJ*/traceln("Throw     cls = "+cls+" Class_getCno(cls)="+Class_getCno(cls));
///*IFJ*/traceln();

                    assume(sp == lp + Frame_getStackOffset(lp)); /* Reset sp */

                    while(true) {
                        int i, klass;
                        int mp = Frame_getCurrentMp(lp);
                        int headerSize = getUnsignedByte(mp, MTH_headerSize);
                        int oopMapSize = (getUnsignedByte(mp, MTH_numberOfLocals) + 7) / 8;
                        int p = 5 + oopMapSize;
                        int hcount = (headerSize - p) / 8;
                        int relip = ip - mp;
///*IFJ*/traceln("Throw     lp = "+lp);
///*IFJ*/traceln("Throw     mp = "+mp);
///*IFJ*/traceln("Throw     ip = "+relip);
///*IFJ*/traceln("Throw hcount = "+hcount);

                      for (i = 0 ; i < hcount ; i++) {
                          int startIP, endIP, handlerIP, classNum;
                          startIP    = fetchUnsignedShort(mp+p); p += 2;
                          endIP      = fetchUnsignedShort(mp+p); p += 2;
                          handlerIP  = fetchUnsignedShort(mp+p); p += 2;
                          classNum   = fetchUnsignedShort(mp+p); p += 2;
///*IFJ*/traceln("Throw     startIP="+startIP+ " endIP="+endIP+ " handlerIP="+handlerIP+ " classNum="+classNum);

                         /*
                          * Test to see if the ip matches. The value of ip will be in the (inclusive) range
                          * [X+1 .. Y] where X is the address of the instruction that caused the
                          * exception to occur and Y is the address of the next instruction. The
                          * ambiguity is due to the fact an exception may be raised while the
                          * interpreter has not completed decoding the exception causing
                          * instruction (e.g. null receiver for a virtual method invocation).
                          * For this reason, the test below comparing ip to endIP is "<="
                          * as opposed to "<".
                          */
                          if (relip >= startIP && relip <= endIP) {
                             /*
                              * Iterate up the class hierarchy lookin for a match
                              */
                              for (klass = cls ; klass != 0 ; klass = Class_getSuperClass(klass)) {
///*IFJ*/traceln("Throw     Class_getCno(klass) = "+Class_getCno(klass)+" classNum="+classNum);

                                    if (Class_getCno(klass) == classNum) {
                                       /*
                                        * Got a match.
                                        */
                                        ip = mp+handlerIP;
                                        push(exception);
/*IFJ*/                                 continue loop;
//IFC//                                 goto loop;
                                    }
                                }
                            }
                        }
                        #popframe
                    }
                }


                /*-----------------------------------------------------------*\
                 *                       New objects                         *
                \*-----------------------------------------------------------*/

                case OPC_NEWOBJECT: {
                    int restartIP = ip - 1;                             // Get restart address
                    int obj = Frame_getLocal(lp, 0);                    // Get the receiver
                    if (obj == 0) {                                     // Is is zero?
                        obj = newInstance(cp);                          // Y - Allocate object
                        if (obj == 0) {                                 // OK?
                            int cc = getChunkFromFrame(lp);             // N - Get current chunk
                            Frame_setCurrentIp(lp, restartIP);          // Set to re-execute the extend
                            //Frame_setStackOffset(lp, sp - lp);          // Save the stack offset
                            assume(Frame_getStackOffset(lp) == sp - lp);
                            StackChunk_setLastLp(cc, lp);               // Save the lp
                            return cc;                                  // Go do gc
                        }
                    }
                    Frame_setLocal(lp, 0, obj);                         // Save the  result
                    continue;
                }

                case OPC_NEWARRAY:
                    fn = VMExtension_newArray_17;
                    break;

                case OPC_NEWDIMENSION:
                    fn = VMExtension_newDimension_18;
                    break;


                /*-----------------------------------------------------------*\
                 *                       Array loads                         *
                \*-----------------------------------------------------------*/

                case OPC_ALOAD: {
                    int ndx = pop();
                    int ref = pop();
                    #nullBoundsCheck(ref, ndx)
                    push(getWord(ref, ndx));
                    continue;
                }

                case OPC_ALOAD_B: {
                    int ndx = pop();
                    int ref = pop();
                    #nullBoundsCheck(ref, ndx)
                    push(getByte(ref, ndx));
                    continue;
                }

                case OPC_ALOAD_S: {
                    int ndx = pop();
                    int ref = pop();
                    #nullBoundsCheck(ref, ndx)
                    push(getHalf(ref, ndx));
                    continue;
                }

                case OPC_ALOAD_C: {
                    int ndx = pop();
                    int ref = pop();
                    #nullBoundsCheck(ref, ndx)
                    push(getUnsignedHalf(ref, ndx));
                    continue;
                }

                case OPC_ALOAD_I2: {
                    int ndx = pop();
                    int ref = pop();
                    #nullBoundsCheck(ref, ndx)
                    pushLong(getLong(ref, ndx));
                    continue;
                }

                /*-----------------------------------------------------------*\
                 *                       Array stores                        *
                \*-----------------------------------------------------------*/

                case OPC_ASTORE: {
                    int val = pop();
                    int ndx = pop();
                    int ref = pop();
                    #nullBoundsCheck(ref, ndx)
                    setWord(ref, ndx, val);
                    continue;
                }

                case OPC_ASTORE_B: {
                    int val = pop();
                    int ndx = pop();
                    int ref = pop();
                    #nullBoundsCheck(ref, ndx)
                    setByte(ref, ndx, val);
                    continue;
                }

                case OPC_ASTORE_S: {
                    int val = pop();
                    int ndx = pop();
                    int ref = pop();
                    #nullBoundsCheck(ref, ndx)
                    setHalf(ref, ndx, val);
                    continue;
                }

                case OPC_ASTORE_O: {
                    int val = pop();
                    int ndx = pop();
                    int ref = pop();
                    #nullBoundsCheck(ref, ndx)
                    setOop(ref, ndx, val);
                    continue;
                }

                case OPC_ASTORE_I2: {
                    long val = popLong();
                    int  ndx = pop();
                    int  ref = pop();
                    #nullBoundsCheck(ref, ndx)
                    setLong(ref, ndx, val);
                    continue;
                }

                /*-----------------------------------------------------------*\
                 *                      Get/Putfields                        *
                \*-----------------------------------------------------------*/


                #comment {
                /*------------------------------------*\
                 *           Getfield prefix
                \*------------------------------------*/
                }
                #def getfield(suffix) {
                    case OPC_THIS_GETFIELD#suffix:
                        push(Frame_getLocal(lp, 0));
                    case OPC_GETFIELD#suffix:
                }

                #comment {
                /*------------------------------------*\
                 *           Putfield prefix
                \*------------------------------------*/
                }
                #def putfield(suffix) {
                    case OPC_THIS_PUTFIELD#suffix: {
                        int val = pop();
                        push(Frame_getLocal(lp, 0));
                        push(val);
                    }
                    case OPC_PUTFIELD#suffix:
                }



                #getfield() {
                    int ref = pop();
                    int off = fetchUnsignedByte(ip++);
                    #checkfield_w(ref, off)
                    push(getWord(ref, off));
                    continue;
                }

                #getfield(_B) {
                    int ref = pop();
                    int off = fetchUnsignedByte(ip++);
                    #checkfield_b(ref, off)
                    push(getByte(ref, off));
                    continue;
                }

                #getfield(_S) {
                    int ref = pop();
                    int off = fetchUnsignedByte(ip++);
                    #checkfield_h(ref, off)
                    push(getHalf(ref, off));
                    continue;
                }

                #getfield(_C) {
                    int ref = pop();
                    int off = fetchUnsignedByte(ip++);
                    #checkfield_h(ref, off)
                    push(getUnsignedHalf(ref, off));
                    continue;
                }

                #getfield(_I2) {
                    int ref = pop();
                    int off = fetchUnsignedByte(ip++);
                    #checkfield_l(ref, off)
                    pushLong(getLongAtWord(ref, off));
                    continue;
                }

                #putfield() {
                    int val = pop();
                    int ref = pop();
                    int off = fetchUnsignedByte(ip++);
                    #checkfield_w(ref, off)
                    setWord(ref, off, val);
                    continue;
                }

                #putfield(_B) {
                    int val = pop();
                    int ref = pop();
                    int off = fetchUnsignedByte(ip++);
                    #checkfield_b(ref, off)
                    setByte(ref, off, val);
                    continue;
                }

                #putfield(_S) {
                    int val = pop();
                    int ref = pop();
                    int off = fetchUnsignedByte(ip++);
                    #checkfield_h(ref, off)
                    setHalf(ref, off, val);
                    continue;
                }

                #putfield(_O) {
                    int val = pop();
                    int ref = pop();
                    int off = fetchUnsignedByte(ip++);
                    checkAddress(val, 0);
                    #checkfield_w(ref, off)
                    setOop(ref, off, val);
                    continue;
                }

                #putfield(_I2) {
                    long val = popLong();
                    int  ref = pop();
                    int  off = fetchUnsignedByte(ip++);
                    #checkfield_l(ref, off)
                    setLongAtWord(ref, off, val);
                    continue;
                }

                /*-----------------------------------------------------------*\
                 *                      Get/Putstatics                       *
                \*-----------------------------------------------------------*/


                #comment {
                /*------------------------------------*\
                 *          Getstatic prefix
                \*------------------------------------*/
                }

                #def getstatic(suffix) {
                    case OPC_CLASS_GETSTATIC#suffix:
                        push(cp);
                    case OPC_GETSTATIC#suffix:
                }


                #comment {
                /*------------------------------------*\
                 *          Putstatic prefix
                \*------------------------------------*/
                }

                #def putstatic(suffix) {
                    case OPC_CLASS_PUTSTATIC#suffix: {
                        //int val = pop();
                        push(cp);
                        //push(val);
                    }
                    case OPC_PUTSTATIC#suffix:
                }


                #comment {
                /*------------------------------------*\
                 *      Code to find class state
                \*------------------------------------*/
                }

                #def if_cs_found(cls) {
                    int hash = Class_getCno(#cls#) & (CLS_STATE_TABLE_SIZE - 1);
                    int cs = getWord(getClassStateTable(), hash);
                    if (cs == 0 || ClassState_getClass(cs) != #cls#) {
                        cs = findClassState(cls, hash);
                    }
                    assume(cs == 0 || Object_isArray(cs));
                    if (cs != 0)
                }




                #getstatic() {
                    int offset = fetchUnsignedByte(ip++);
                    int cls = pop();
                    #if_cs_found(cls) {
///*IFJ*/traceln("getstatic cp="+cp+" cls="+cls+" offset ="+offset+" cs="+cs+" getWord(cs, offset)="+getWord(cs, offset));
                        assume(Object_isInBounds(cs, offset));
                        push(getWord(cs, offset));
                        continue;
                    } else {
                        push(offset);
                        push(cls);
                        fn = VMExtension_getStatic_10;
                        break;
                    }
                }

                #getstatic(_I2) {
                    int offset = fetchUnsignedByte(ip++);
                    int cls = pop();
                    #if_cs_found(cls) {
                        assume(Object_isInBounds(cs, offset));
                        pushLong(getLongAtWord(cs, offset));
                        continue;
                    } else {
                        push(offset);
                        push(cls);
                        fn = VMExtension_getStaticLong_11;
                        break;
                    }
                }

                #putstatic() {
                    int offset = fetchUnsignedByte(ip++);
                    int cls = pop();
                    int val = pop();
                    #if_cs_found(cls) {
///*IFJ*/traceln("putstatic cls="+cls+" offset ="+offset+" cs="+cs+" val="+val);
                        assume(Object_isInBounds(cs, offset));
                        setWord(cs, offset, val);
                        continue;
                    } else {
                        push(val);
                        push(offset);
                        push(cls);
                        fn = VMExtension_putStatic_12;
                        break;
                    }
                }

                #putstatic(_O) {
                    int offset = fetchUnsignedByte(ip++);
                    int cls = pop();
                    int val = pop();
                    #if_cs_found(cls) {
///*IFJ*/traceln("putstatic_o cls="+cls+" offset ="+offset+" cs="+cs+" val="+val);
                        assume(Object_isInBounds(cs, offset));
                        checkAddress(val, 0);
                        setOop(cs, offset, val);
                        continue;
                    } else {
                        checkAddress(val, 0);
                        push(val);
                        push(offset);
                        push(cls);
                        fn = VMExtension_putStaticObj_14;
                        break;
                    }
                }

                #putstatic(_I2) {
                    int  offset = fetchUnsignedByte(ip++);
                    int  cls = pop();
                    long val = popLong();
                    #if_cs_found(cls) {
                        assume(Object_isInBounds(cs, offset));
                        setLongAtWord(cs, offset, val);
                        continue;
                    } else {
                        pushLong(val);
                        push(offset);
                        push(cls);
                        fn = VMExtension_putStaticLong_13;
                        break;
                    }
                }

                case OPC_CLASS_CLINIT:
                    push(cp);
                case OPC_CLINIT: {
                    int cls = pop();
                    #if_cs_found(cls) {
                        continue;
                    } else {
                        push(cls);
                        fn = VMExtension_initializeClass_2;
                        break;
                    }
                }


                /*-----------------------------------------------------------*\
                 *                      Integer ops                          *
                \*-----------------------------------------------------------*/

                case OPC_IADD:  { int r = pop() ; int l = pop() ; push(l + r);      continue; }
                case OPC_ISUB:  { int r = pop() ; int l = pop() ; push(l - r);      continue; }
                case OPC_IAND:  { int r = pop() ; int l = pop() ; push(l & r);      continue; }
                case OPC_IOR:   { int r = pop() ; int l = pop() ; push(l | r);      continue; }
                case OPC_IXOR:  { int r = pop() ; int l = pop() ; push(l ^ r);      continue; }
                case OPC_ISHL:  { int r = pop() ; int l = pop() ; push(l << r);     continue; }
                case OPC_ISHR:  { int r = pop() ; int l = pop() ; push(l >> r);     continue; }
                case OPC_IUSHR: { int r = pop() ; int l = pop() ; push(srl(l, r));  continue; }
                case OPC_IMUL:  { int r = pop() ; int l = pop() ; push(l * r);      continue; }
                case OPC_NEG:   { int r = pop() ;                 push(0 - r);      continue; }
                case OPC_I2B:   { int r = pop() ;                 push((byte)r);    continue; }
                case OPC_I2S:   { int r = pop() ;                 push((short)r);   continue; }
                case OPC_I2C:   { int r = pop() ;                 push((char)r);    continue; }

                case OPC_IDIV: {
                    int r = pop();
                    int l = pop();
                    #div0Check(r)
///*IFJ*/traceln("idiv r="+r+" l="+l+" res="+(l/r));
                    push(l / r);
                    continue;
                }

                case OPC_IREM: {
                    int r = pop();
                    int l = pop();
                    #div0Check(r)
                    push(l % r);
                    continue;
                }


                /*-----------------------------------------------------------*\
                 *                        Long ops                           *
                \*-----------------------------------------------------------*/
/*if[LONGS]*/
                case OPC_LONGOP: {
                    b = fetchUnsignedByte(ip++);
                    switch (b) {
                        case OPC_LADD: { long r = popLong() ; long l = popLong() ; pushLong(l + r);     continue; }
                        case OPC_LSUB: { long r = popLong() ; long l = popLong() ; pushLong(l - r);     continue; }
                        case OPC_LMUL: { long r = popLong() ; long l = popLong() ; pushLong(l * r);     continue; }
                        case OPC_LAND: { long r = popLong() ; long l = popLong() ; pushLong(l & r);     continue; }
                        case OPC_LOR:  { long r = popLong() ; long l = popLong() ; pushLong(l | r);     continue; }
                        case OPC_LXOR: { long r = popLong() ; long l = popLong() ; pushLong(l ^ r);     continue; }
                        case OPC_LNEG: { long r = popLong() ;                      pushLong(0 - r);     continue; }
                        case OPC_LSHL: { int  r = pop()     ; long l = popLong() ; pushLong(l << r);    continue; }
                        case OPC_LSHR: { int  r = pop()     ; long l = popLong() ; pushLong(l >> r);    continue; }
                        case OPC_LUSHR:{ int  r = pop()     ; long l = popLong() ; pushLong(srll(l, r));continue; }
                        case OPC_LCMP: { long r = popLong() ; long l = popLong() ; push(cmpl(l, r));    continue; }
                        case OPC_I2L:  { int  r = pop()     ;                      pushLong(r);         continue; }
                        case OPC_L2I:  { long r = popLong() ;                      push((int)r);        continue; }

                        case OPC_LDIV: {
                            long r = popLong();
                            long l = popLong();
                            #div0Check(r)
                            pushLong(l / r);
                            continue;
                        }

                        case OPC_LREM: {
                            long r = popLong();
                            long l = popLong();
                            #div0Check(r)
                            pushLong(l % r);
                            continue;
                        }
                    }
                    fatalVMError("invalid long bytecode");
                }
/*end[LONGS]*/

                /*-----------------------------------------------------------*\
                 *                        Float ops                          *
                \*-----------------------------------------------------------*/

/*if[FLOATS]*/
                case OPC_FLOATOP: {
                    b = fetchUnsignedByte(ip++);
                    switch (b) {
                        case OPC_FADD: { int  r = pop()     ; int  l = pop()     ; push(addf(l, r));        continue; }
                        case OPC_FSUB: { int  r = pop()     ; int  l = pop()     ; push(subf(l, r));        continue; }
                        case OPC_FMUL: { int  r = pop()     ; int  l = pop()     ; push(mulf(l, r));        continue; }
                        case OPC_FDIV: { int  r = pop()     ; int  l = pop()     ; push(divf(l, r));        continue; }
                        case OPC_FREM: { int  r = pop()     ; int  l = pop()     ; push(remf(l, r));        continue; }
                        case OPC_FNEG: { int  r = pop()     ;                      push(negf(r));           continue; }
                        case OPC_FCMPG:{ int  r = pop()     ; int  l = pop()     ; push(cmpfg(l, r));       continue; }
                        case OPC_FCMPL:{ int  r = pop()     ; int  l = pop()     ; push(cmpfl(l, r));       continue; }
                        case OPC_DADD: { long r = popLong() ; long l = popLong() ; pushLong(addd(l, r));    continue; }
                        case OPC_DSUB: { long r = popLong() ; long l = popLong() ; pushLong(subd(l, r));    continue; }
                        case OPC_DMUL: { long r = popLong() ; long l = popLong() ; pushLong(muld(l, r));    continue; }
                        case OPC_DDIV: { long r = popLong() ; long l = popLong() ; pushLong(divd(l, r));    continue; }
                        case OPC_DREM: { long r = popLong() ; long l = popLong() ; pushLong(remd(l, r));    continue; }
                        case OPC_DNEG: { long r = popLong() ;                      pushLong(negd(r));       continue; }
                        case OPC_DCMPG:{ long r = popLong() ; long l = popLong() ; push(cmpdg(l, r));       continue; }
                        case OPC_DCMPL:{ long r = popLong() ; long l = popLong() ; push(cmpdl(l, r));       continue; }
                        case OPC_I2F:  { int  r = pop()     ;                      push(i2f(r));            continue; }
                        case OPC_L2F:  { long r = popLong() ;                      push(l2f(r));            continue; }
                        case OPC_F2I:  { int  r = pop()     ;                      push(f2i(r));            continue; }
                        case OPC_F2L:  { int  r = pop()     ;                      pushLong(f2l(r));        continue; }
                        case OPC_I2D:  { int  r = pop()     ;                      pushLong(i2d(r));        continue; }
                        case OPC_L2D:  { long r = popLong() ;                      pushLong(l2d(r));        continue; }
                        case OPC_F2D:  { int  r = pop()     ;                      pushLong(f2d(r));        continue; }
                        case OPC_D2I:  { long r = popLong() ;                      push(d2i(r));            continue; }
                        case OPC_D2L:  { long r = popLong() ;                      pushLong(d2l(r));        continue; }
                        case OPC_D2F:  { long r = popLong() ;                      push(d2f(r));            continue; }
                        default:
                    }
                    fatalVMError("invalid float bytecode");
                }
/*end[FLOATS]*/

                /*-----------------------------------------------------------*\
                 *                            Misc                           *
                \*-----------------------------------------------------------*/

                case OPC_POP:
                    pop();
                case OPC_NOP:
                    continue;

                case OPC_ARRAYLENGTH: {
                    int ref = pop();
                    assume(Object_isArray(ref));
                    if (ref == 0) {
                        fn = VMExtension_nullPointerException_5;
                        break;
                    }
                    push(Object_getLength(ref));
                    continue;
                }

                case OPC_CLASS_MONITORENTER:
                    push(cp);
                case OPC_MONITORENTER:
                    fn = VMExtension_monitorEnter_15;
                    break;

                case OPC_CLASS_MONITOREXIT:
                    push(cp);
                case OPC_MONITOREXIT:
                    fn = VMExtension_monitorExit_16;
                    break;

                case OPC_INSTANCEOF:
                    fn = VMExtension_instanceof_7;
                    break;

                case OPC_CHECKCAST:
                    fn = VMExtension_checkcast_6;
                    break;

                case OPC_BPT:
                    fn = VMExtension_breakpoint_19;
                    break;


                /*-----------------------------------------------------------*\
                 *                       Invoke native                       *
                \*-----------------------------------------------------------*/

                case OPC_INVOKENATIVE:
                case OPC_INVOKENATIVE1:
                case OPC_INVOKENATIVE2: {
                    int parm = fetchUnsignedByte(ip++);
                    incInvokePrimitiveCount();
                    pop(); /* pop the unwanted class reference */
                    switch (parm) {
                        case Native_parm_10:
                        case Native_parm_11:
                            nativeParms[nativePointer++] = pop();
                            assume(nativePointer != 16);
                            continue;

                        case Native_exec_6:
                        case Native_exec_7:
                        case Native_exec_8: {
                            push(chan_execute(pop(), nativeParms, nativePointer));
                            nativePointer = 0;
                            continue;
                        }

                        case Native_error_13:
                            push(chan_error(pop()));
                            continue;

                        case Native_result_14:
                            push(chan_result(pop()));
                            continue;

                        case Native_getNewExecutionContext_15: {
                            int thread = pop();
                            int ctx = createExecutionContext(VMExtension_callrun_20, thread);
                            push(ctx);
                            continue;
                        }

                        case Native_setExecutionContext_16: {
                            int id        = pop();
                            int newThread = pop();
                            int oldThread = pop();
                            int cc = getChunkFromFrame(lp);
///*IFJ*/traceln("old ctx="+cc);
                            if (oldThread != 0) {
                                Frame_setCurrentIp(lp, ip);
                                Frame_setCurrentCp(lp, cp);
                                //Frame_setStackOffset(lp, sp - lp);
                                assume(Frame_getStackOffset(lp) == sp - lp);
                                StackChunk_setLastLp(cc, lp);
                                Thread_setContext(oldThread, cc);
                            }
                            cc = Thread_getContext(newThread);
///*IFJ*/traceln("new ctx="+cc);
                            lp = StackChunk_getLastLp(cc);
                            ip = Frame_getCurrentIp(lp);
                            cp = Frame_getCurrentCp(lp);
                            sp = lp + Frame_getStackOffset(lp);
                            sl = cc + StackChunk_getSize(cc);
///*IFJ*/traceln("new ctx sl="+sl);
                            bc = TIMEQUANTA;
                            StackChunk_setLastLp(cc, 0);
                            incSwitchCount();
                            threadID = id;
                            continue;
                        }

                        case Native_primNewArray_17: {
                            int siz = pop();
                            int cls = pop();
                            push(newArray(cls, siz));
                            continue;
                        }

                        case Native_callStaticNoParm_18:
                        case Native_callStaticOneParm_19: {
                            int mp;
                            int vtbl;
                            int slot;
                            slot = pop();
                            cp   = pop();
                            #pushFrame
                            vtbl = Class_getStaticMethods(cp);
                            assume(Object_isInBounds(vtbl, slot));
                            mp = getWord(vtbl, slot);
                            #setupFrame
                            continue;
                        }

                        case Native_getSuiteList_20: {
                            int res = getSuiteTable(EEPROM);
                            if (res == 0) {
                                res = getSuiteTable(ROM);
                            }
                            push(res);
                            continue;
                        }

                        case Native_setSuiteList_21: {
                            setSuiteTable(EEPROM, pop());
                            continue;
                        }

                        case Native_setOutOfMemoryError_22: {
                            setOutOfMemoryError(pop());
                            continue;
                        }

                        case Native_getargc_23: {
                            push(getArgumentCount());
                            continue;
                        }

                        case Native_getargvchar_24: {
                            int pos = pop();
                            int arg = pop();
                            push(getArgumentChar(arg, pos));
                            continue;
                        }
                        case Native_exit_25: {
                            exitVM(pop());
                            continue;
                        }
                        case Native_gc_26: {
                            int cc = getChunkFromFrame(lp);             // Get current chunk
                            Frame_setCurrentIp(lp, ip);                 // Set to execute the next bytecode
                            assume(Frame_getStackOffset(lp) == sp - lp);
                            StackChunk_setLastLp(cc, lp);               // Save the lp
                            return cc;                                  // Go do gc
                        }
                        case Native_freemem_27: {
                            pushLong(freeMem());
                            continue;
                        }
                        case Native_totalmem_28: {
                            pushLong(totalMem());
                            continue;
                        }
                        case Native_gettime_29: {
                            pushLong(getTime());
                            continue;
                        }
                        case Native_arraycopy_30: {
                            int length = pop();
                            int dstPos = pop();
                            int dst    = pop();
                            int srcPos = pop();
                            int src    = pop();
                            arrayCopy(src, srcPos, dst, dstPos, length);
                            continue;
                        }
                        case Native_getevent_31: {
                            push(getEvent());
                            continue;
                        }
                        case Native_waitforevent_32: {
                            waitForEvent(popLong());
                            continue;
                        }
                        case Native_fatalvmerror_33: {
                            fatalVMError("Native.fatalvmerror()");
                            continue;
                        }
                        case Native_getclass_34: {
                            push(Object_getClass(pop()));
                            continue;
                        }
                        case Native_getarraylength_35: {
                            push(Object_getLength(pop()));
                            continue;
                        }
                        case Native_putch_36: {
                            printCh(pop());
                            continue;
                        }

                        case Native_getMonitorQueue_37: {
                            push(getMonitorQueue());
                            continue;
                        }
                        case Native_setMonitorQueue_38: {
                            setMonitorQueue(pop());
                            continue;
                        }

                        case Native_getClassState_39: {
                            int cls = pop();
                            #if_cs_found(cls) {
                                push(cs);
                            } else {
                                push(cs);
                            }
                            continue;
                        }

                        case Native_createClassState_40: {
                            int cls = pop();
                            int siz = Class_getStaticFieldsLength(cls);
                            int cs = newArray(getClassFromCNO(GLOBAL_ARRAY), CLS_STATE_offsetToFields + siz);
                            push(cs);
                            continue;
                        }

                        case Native_primGetStatic_41: {
                            int offset = pop();
                            int cs     = pop();
                            if (cs != 0) {
                                assume(Object_isInBounds(cs, offset));
                                push(getWord(cs, offset));
                            } else {
                                fatalVMError("Primitive static failure");
                            }
                            continue;
                        }

                        case Native_primGetStaticLong_42: {
                            int offset = pop();
                            int cs     = pop();
                            if (cs != 0) {
                                assume(Object_isInBounds(cs, offset));
                                pushLong(getLongAtWord(cs, offset));
                            } else {
                                fatalVMError("Primitive static failure");
                            }
                            continue;
                        }

                        case Native_primPutStatic_43: {
                            int val    = pop();
                            int offset = pop();
                            int cs     = pop();
                            if (cs != 0) {
                                assume(Object_isInBounds(cs, offset));
                                setWord(cs, offset, val);
                            } else {
                                fatalVMError("Primitive static failure");
                            }
                            continue;
                        }

                        case Native_primPutStaticLong_44: {
                            long val    = popLong();
                            int  offset = pop();
                            int  cs     = pop();
                            if (cs != 0) {
                                assume(Object_isInBounds(cs, offset));
                                setLongAtWord(cs, offset, val);
                            } else {
                                fatalVMError("Primitive static failure");
                            }
                            continue;
                        }

                        case Native_primPutStaticObj_45: {
                            int val    = pop();
                            int offset = pop();
                            int cs     = pop();
                            if (cs != 0) {
                                assume(Object_isInBounds(cs, offset));
                                setOop(cs, offset, val);
                            } else {
                                fatalVMError("Primitive static failure");
                            }
                            continue;
                        }


                        case Native_setClassState_46: {
                            int cs  = pop();
                            int cls = pop();
                            addToClassState(cls, cs);
                            continue;
                        }

                        case Native_primNewObject_47: {
                            int slot = pop();
                            int cls  = pop();
                            int res  = newInstance(cls);
                            push(res);
                            if (res != 0) {
                                int mp;
                                int vtbl;
                                incInvokeCount();
                                #pushFrame
                                vtbl = Class_getStaticMethods(cls);
                                assume(Object_isInBounds(vtbl, slot));
                                mp = getWord(vtbl, slot);
                                #setupFrame
                            }
                            continue;
                        }

/*if[FLOATS]*/
                        case Native_math: {
                            long long2 = popLong();
                            long long1 = popLong();
                            int op = pop();
                            pushLong(math0(op, long1, long2));
                            continue;
                        }
                        case Native_floatToIntBits:
                        case Native_doubleToLongBits:
                        case Native_intBitsToFloat:
                        case Native_longBitsToDouble:
                            continue;
/*end[FLOATS]*/
                    }
                    continue;
                }

                case OPC_METHODID: {
                    ip += 4;
                    continue;
                }

                default: {
                    fatalVMError("Bad bytecode");
                }

            } // end of switch

                /*-----------------------------------------------------------*\
                 *                     Exception handling                    *
                \*-----------------------------------------------------------*/


        {
            int mp;
            int vtbl;


///*IFJ*/traceln("fn="+fn);


            #pushFrame

            cp = getClassFromCNO(VMEXTENSION);                  // Setup the class
            vtbl = Class_getStaticMethods(cp);                  // Get the vtable for virtual methods
            assume(Object_isInBounds(vtbl, fn));
            mp = getWord(vtbl, fn);                             // Get the method

            #setupFrame

        }


        if (fn == VMExtension_yield_9) {
            bc = TIMEQUANTA;
        }
        fn = VMExtension_yield_9;


        } // end of for loop

    }


    /*---------------------------------------------------------------------------*\
     *                                  Entrypoint                               *
    \*---------------------------------------------------------------------------*/


//IFC//public void run() {
/*IFJ*/public void run2() {
        boolean gcWorked = true;
        int restart;

       /*
        * Enable the Object_isArray check
        */
        checkArrays = true;

       /*
        * Create the class state table
        */
        if (getClassStateTable() == 0) {
            int cst = newArray(getClassFromCNO(OBJECT_ARRAY), CLS_STATE_TABLE_SIZE);
            setClassStateTable(cst);
        }

       /*
        * Get the current chunk
        */
        restart = getCurrentStackChunk();
        if (restart == 0) {
            restart = createExecutionContext(VMExtension_vmstart_1, 0);
        }

        /*
         * Loop forever
         */
        for (;;) {
            /*
             * Run the interpreter until the garbage needs collecting
             */
            restart = interpret(restart, gcWorked);

            /*
             * Save the current activation record and run the gc
             */
            setCurrentStackChunk(restart);
            gcWorked = gc();
            restart = getCurrentStackChunk();
        }
    }

/*IFJ*/public void run() {
/*IFJ*/    try {
/*IFJ*/        run2();
/*IFJ*/    } catch (Throwable ex) {
/*IFJ*/        traceln(""+ex);
/*IFJ*/        ex.printStackTrace(traceStream);
/*IFJ*/    }
/*IFJ*/}


/*IFJ*/}





/*
    void traceInstruction(int ip, int lp, int sp, int cp) {
        if (getTraceInstructions()) {



            int soff = Frame_getStackOffset(lp);
            int s0 = lp + soff;//lp + ((soff == 0) ? -4 : soff);
            int b  = fetchUnsignedByte(ip);
            int mp = Frame_getCurrentMp(lp);
            int frames = countFrames(lp);

            if (mp != lastMp) {
                int methodIdAddr = getMethodIdAddress(mp);
                if (lastMID != -1) {
                    lastMID      = fetchInt(methodIdAddr);
                    lastPreamble = methodIdAddr + 4;
                } else {
                    lastMID      = -1;
                    lastPreamble = -1;
                }
                lastMp = mp;
            }

            trace("*TRACE*");
            traceInt(threadID);        trace(":"); // thread id
            traceInt(frames);          trace(":");
            traceInt(lastMID);         trace(":");
            traceInt(ip-lastPreamble); trace(":");


            String res = "";

            res += "("+sp+")";
            while (res.length() < 13) {
               res += " ";
            }

            for (int i = s0+w2b(1) ; i <= sp ; i += w2b(1)) {
                res += " "+getWord(i, 0);
            }

            while (res.length() < 40) {
               res += " ";
            }

            ip++;

            if ((b >= OPC_WIDE_0 && b <= OPC_WIDE_15) || b == OPC_WIDE_HALF) {
                res += "["+mnemonics[b]+"] ";
                int offset;
                if (b == OPC_WIDE_HALF) {
                    b = fetchUnsignedByte(ip++);
                    offset = fetchShort(ip);
                } else {
                    int wide_15 = (b&15) << 8;
                    b = fetchUnsignedByte(ip++);
                    offset = wide_15 | fetchUnsignedByte(ip);
                    offset = offset << 20 >> 20;
                }
                res += mnemonics[b]+" "+offset;
            } else if (b == OPC_LONGOP) {
                res += longMnemonics[fetchUnsignedByte(ip)];
            } else if (b == OPC_FLOATOP) {
                res += floatMnemonics[fetchUnsignedByte(ip)];
            } else {
                res += mnemonics[b];
                int blth = (byte)(mainTable.charAt(b) >> 8);
                if (blth > 1) {
                    if (blth == 2) {
                        switch (b) {
                            case OPC_IF_ICMPEQ:  case OPC_IFEQ:
                            case OPC_IF_ICMPNE:  case OPC_IFNE:
                            case OPC_IF_ICMPLT:  case OPC_IFLT:
                            case OPC_IF_ICMPLE:  case OPC_IFLE:
                            case OPC_IF_ICMPGT:  case OPC_IFGT:
                            case OPC_IF_ICMPGE:  case OPC_IFGE:
                            case OPC_GOTO: res += " "+fetchByte(ip);         break;
                            default:       res += " "+fetchUnsignedByte(ip); break;
                        }
                    } else if (blth == 3) {
                        res += " "+fetchShort(ip);
                    } else if (blth == 5) {
                        res += " "+fetchInt(ip);
                    } else if (blth == 9) {
                        res += " "+fetchLong(ip);
                    } else {
                        res += " ???";
                    }
                }
            }

            traceln(res);
        }
    }
*/